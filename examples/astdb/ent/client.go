// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/safedep/code/examples/astdb/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/safedep/code/examples/astdb/ent/astnode"
	"github.com/safedep/code/examples/astdb/ent/callrelationship"
	"github.com/safedep/code/examples/astdb/ent/file"
	"github.com/safedep/code/examples/astdb/ent/importstatement"
	"github.com/safedep/code/examples/astdb/ent/inheritancerelationship"
	"github.com/safedep/code/examples/astdb/ent/project"
	"github.com/safedep/code/examples/astdb/ent/symbol"
	"github.com/safedep/code/examples/astdb/ent/symbolreference"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ASTNode is the client for interacting with the ASTNode builders.
	ASTNode *ASTNodeClient
	// CallRelationship is the client for interacting with the CallRelationship builders.
	CallRelationship *CallRelationshipClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// ImportStatement is the client for interacting with the ImportStatement builders.
	ImportStatement *ImportStatementClient
	// InheritanceRelationship is the client for interacting with the InheritanceRelationship builders.
	InheritanceRelationship *InheritanceRelationshipClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Symbol is the client for interacting with the Symbol builders.
	Symbol *SymbolClient
	// SymbolReference is the client for interacting with the SymbolReference builders.
	SymbolReference *SymbolReferenceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ASTNode = NewASTNodeClient(c.config)
	c.CallRelationship = NewCallRelationshipClient(c.config)
	c.File = NewFileClient(c.config)
	c.ImportStatement = NewImportStatementClient(c.config)
	c.InheritanceRelationship = NewInheritanceRelationshipClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Symbol = NewSymbolClient(c.config)
	c.SymbolReference = NewSymbolReferenceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ASTNode:                 NewASTNodeClient(cfg),
		CallRelationship:        NewCallRelationshipClient(cfg),
		File:                    NewFileClient(cfg),
		ImportStatement:         NewImportStatementClient(cfg),
		InheritanceRelationship: NewInheritanceRelationshipClient(cfg),
		Project:                 NewProjectClient(cfg),
		Symbol:                  NewSymbolClient(cfg),
		SymbolReference:         NewSymbolReferenceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		ASTNode:                 NewASTNodeClient(cfg),
		CallRelationship:        NewCallRelationshipClient(cfg),
		File:                    NewFileClient(cfg),
		ImportStatement:         NewImportStatementClient(cfg),
		InheritanceRelationship: NewInheritanceRelationshipClient(cfg),
		Project:                 NewProjectClient(cfg),
		Symbol:                  NewSymbolClient(cfg),
		SymbolReference:         NewSymbolReferenceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ASTNode.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ASTNode, c.CallRelationship, c.File, c.ImportStatement,
		c.InheritanceRelationship, c.Project, c.Symbol, c.SymbolReference,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ASTNode, c.CallRelationship, c.File, c.ImportStatement,
		c.InheritanceRelationship, c.Project, c.Symbol, c.SymbolReference,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ASTNodeMutation:
		return c.ASTNode.mutate(ctx, m)
	case *CallRelationshipMutation:
		return c.CallRelationship.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *ImportStatementMutation:
		return c.ImportStatement.mutate(ctx, m)
	case *InheritanceRelationshipMutation:
		return c.InheritanceRelationship.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *SymbolMutation:
		return c.Symbol.mutate(ctx, m)
	case *SymbolReferenceMutation:
		return c.SymbolReference.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ASTNodeClient is a client for the ASTNode schema.
type ASTNodeClient struct {
	config
}

// NewASTNodeClient returns a client for the ASTNode from the given config.
func NewASTNodeClient(c config) *ASTNodeClient {
	return &ASTNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `astnode.Hooks(f(g(h())))`.
func (c *ASTNodeClient) Use(hooks ...Hook) {
	c.hooks.ASTNode = append(c.hooks.ASTNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `astnode.Intercept(f(g(h())))`.
func (c *ASTNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ASTNode = append(c.inters.ASTNode, interceptors...)
}

// Create returns a builder for creating a ASTNode entity.
func (c *ASTNodeClient) Create() *ASTNodeCreate {
	mutation := newASTNodeMutation(c.config, OpCreate)
	return &ASTNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ASTNode entities.
func (c *ASTNodeClient) CreateBulk(builders ...*ASTNodeCreate) *ASTNodeCreateBulk {
	return &ASTNodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ASTNodeClient) MapCreateBulk(slice any, setFunc func(*ASTNodeCreate, int)) *ASTNodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ASTNodeCreateBulk{err: fmt.Errorf("calling to ASTNodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ASTNodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ASTNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ASTNode.
func (c *ASTNodeClient) Update() *ASTNodeUpdate {
	mutation := newASTNodeMutation(c.config, OpUpdate)
	return &ASTNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ASTNodeClient) UpdateOne(_m *ASTNode) *ASTNodeUpdateOne {
	mutation := newASTNodeMutation(c.config, OpUpdateOne, withASTNode(_m))
	return &ASTNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ASTNodeClient) UpdateOneID(id int) *ASTNodeUpdateOne {
	mutation := newASTNodeMutation(c.config, OpUpdateOne, withASTNodeID(id))
	return &ASTNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ASTNode.
func (c *ASTNodeClient) Delete() *ASTNodeDelete {
	mutation := newASTNodeMutation(c.config, OpDelete)
	return &ASTNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ASTNodeClient) DeleteOne(_m *ASTNode) *ASTNodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ASTNodeClient) DeleteOneID(id int) *ASTNodeDeleteOne {
	builder := c.Delete().Where(astnode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ASTNodeDeleteOne{builder}
}

// Query returns a query builder for ASTNode.
func (c *ASTNodeClient) Query() *ASTNodeQuery {
	return &ASTNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeASTNode},
		inters: c.Interceptors(),
	}
}

// Get returns a ASTNode entity by its id.
func (c *ASTNodeClient) Get(ctx context.Context, id int) (*ASTNode, error) {
	return c.Query().Where(astnode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ASTNodeClient) GetX(ctx context.Context, id int) *ASTNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a ASTNode.
func (c *ASTNodeClient) QueryFile(_m *ASTNode) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(astnode.Table, astnode.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, astnode.FileTable, astnode.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a ASTNode.
func (c *ASTNodeClient) QueryChildren(_m *ASTNode) *ASTNodeQuery {
	query := (&ASTNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(astnode.Table, astnode.FieldID, id),
			sqlgraph.To(astnode.Table, astnode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, astnode.ChildrenTable, astnode.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a ASTNode.
func (c *ASTNodeClient) QueryParent(_m *ASTNode) *ASTNodeQuery {
	query := (&ASTNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(astnode.Table, astnode.FieldID, id),
			sqlgraph.To(astnode.Table, astnode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, astnode.ParentTable, astnode.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbol queries the symbol edge of a ASTNode.
func (c *ASTNodeClient) QuerySymbol(_m *ASTNode) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(astnode.Table, astnode.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, astnode.SymbolTable, astnode.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReferences queries the references edge of a ASTNode.
func (c *ASTNodeClient) QueryReferences(_m *ASTNode) *SymbolReferenceQuery {
	query := (&SymbolReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(astnode.Table, astnode.FieldID, id),
			sqlgraph.To(symbolreference.Table, symbolreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, astnode.ReferencesTable, astnode.ReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ASTNodeClient) Hooks() []Hook {
	return c.hooks.ASTNode
}

// Interceptors returns the client interceptors.
func (c *ASTNodeClient) Interceptors() []Interceptor {
	return c.inters.ASTNode
}

func (c *ASTNodeClient) mutate(ctx context.Context, m *ASTNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ASTNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ASTNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ASTNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ASTNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ASTNode mutation op: %q", m.Op())
	}
}

// CallRelationshipClient is a client for the CallRelationship schema.
type CallRelationshipClient struct {
	config
}

// NewCallRelationshipClient returns a client for the CallRelationship from the given config.
func NewCallRelationshipClient(c config) *CallRelationshipClient {
	return &CallRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `callrelationship.Hooks(f(g(h())))`.
func (c *CallRelationshipClient) Use(hooks ...Hook) {
	c.hooks.CallRelationship = append(c.hooks.CallRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `callrelationship.Intercept(f(g(h())))`.
func (c *CallRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.CallRelationship = append(c.inters.CallRelationship, interceptors...)
}

// Create returns a builder for creating a CallRelationship entity.
func (c *CallRelationshipClient) Create() *CallRelationshipCreate {
	mutation := newCallRelationshipMutation(c.config, OpCreate)
	return &CallRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CallRelationship entities.
func (c *CallRelationshipClient) CreateBulk(builders ...*CallRelationshipCreate) *CallRelationshipCreateBulk {
	return &CallRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CallRelationshipClient) MapCreateBulk(slice any, setFunc func(*CallRelationshipCreate, int)) *CallRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CallRelationshipCreateBulk{err: fmt.Errorf("calling to CallRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CallRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CallRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CallRelationship.
func (c *CallRelationshipClient) Update() *CallRelationshipUpdate {
	mutation := newCallRelationshipMutation(c.config, OpUpdate)
	return &CallRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CallRelationshipClient) UpdateOne(_m *CallRelationship) *CallRelationshipUpdateOne {
	mutation := newCallRelationshipMutation(c.config, OpUpdateOne, withCallRelationship(_m))
	return &CallRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CallRelationshipClient) UpdateOneID(id int) *CallRelationshipUpdateOne {
	mutation := newCallRelationshipMutation(c.config, OpUpdateOne, withCallRelationshipID(id))
	return &CallRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CallRelationship.
func (c *CallRelationshipClient) Delete() *CallRelationshipDelete {
	mutation := newCallRelationshipMutation(c.config, OpDelete)
	return &CallRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CallRelationshipClient) DeleteOne(_m *CallRelationship) *CallRelationshipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CallRelationshipClient) DeleteOneID(id int) *CallRelationshipDeleteOne {
	builder := c.Delete().Where(callrelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CallRelationshipDeleteOne{builder}
}

// Query returns a query builder for CallRelationship.
func (c *CallRelationshipClient) Query() *CallRelationshipQuery {
	return &CallRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCallRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a CallRelationship entity by its id.
func (c *CallRelationshipClient) Get(ctx context.Context, id int) (*CallRelationship, error) {
	return c.Query().Where(callrelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CallRelationshipClient) GetX(ctx context.Context, id int) *CallRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCaller queries the caller edge of a CallRelationship.
func (c *CallRelationshipClient) QueryCaller(_m *CallRelationship) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(callrelationship.Table, callrelationship.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, callrelationship.CallerTable, callrelationship.CallerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallee queries the callee edge of a CallRelationship.
func (c *CallRelationshipClient) QueryCallee(_m *CallRelationship) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(callrelationship.Table, callrelationship.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, callrelationship.CalleeTable, callrelationship.CalleeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallSiteFile queries the call_site_file edge of a CallRelationship.
func (c *CallRelationshipClient) QueryCallSiteFile(_m *CallRelationship) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(callrelationship.Table, callrelationship.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, callrelationship.CallSiteFileTable, callrelationship.CallSiteFileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CallRelationshipClient) Hooks() []Hook {
	return c.hooks.CallRelationship
}

// Interceptors returns the client interceptors.
func (c *CallRelationshipClient) Interceptors() []Interceptor {
	return c.inters.CallRelationship
}

func (c *CallRelationshipClient) mutate(ctx context.Context, m *CallRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CallRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CallRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CallRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CallRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CallRelationship mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(_m *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(_m))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id int) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(_m *File) *FileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id int) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id int) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id int) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a File.
func (c *FileClient) QueryProject(_m *File) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.ProjectTable, file.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAstNodes queries the ast_nodes edge of a File.
func (c *FileClient) QueryAstNodes(_m *File) *ASTNodeQuery {
	query := (&ASTNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(astnode.Table, astnode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.AstNodesTable, file.AstNodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbols queries the symbols edge of a File.
func (c *FileClient) QuerySymbols(_m *File) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.SymbolsTable, file.SymbolsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImports queries the imports edge of a File.
func (c *FileClient) QueryImports(_m *File) *ImportStatementQuery {
	query := (&ImportStatementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(importstatement.Table, importstatement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.ImportsTable, file.ImportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallSites queries the call_sites edge of a File.
func (c *FileClient) QueryCallSites(_m *File) *CallRelationshipQuery {
	query := (&CallRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(callrelationship.Table, callrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.CallSitesTable, file.CallSitesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInheritanceSites queries the inheritance_sites edge of a File.
func (c *FileClient) QueryInheritanceSites(_m *File) *InheritanceRelationshipQuery {
	query := (&InheritanceRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(inheritancerelationship.Table, inheritancerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.InheritanceSitesTable, file.InheritanceSitesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySymbolReferences queries the symbol_references edge of a File.
func (c *FileClient) QuerySymbolReferences(_m *File) *SymbolReferenceQuery {
	query := (&SymbolReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(symbolreference.Table, symbolreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.SymbolReferencesTable, file.SymbolReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown File mutation op: %q", m.Op())
	}
}

// ImportStatementClient is a client for the ImportStatement schema.
type ImportStatementClient struct {
	config
}

// NewImportStatementClient returns a client for the ImportStatement from the given config.
func NewImportStatementClient(c config) *ImportStatementClient {
	return &ImportStatementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `importstatement.Hooks(f(g(h())))`.
func (c *ImportStatementClient) Use(hooks ...Hook) {
	c.hooks.ImportStatement = append(c.hooks.ImportStatement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `importstatement.Intercept(f(g(h())))`.
func (c *ImportStatementClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImportStatement = append(c.inters.ImportStatement, interceptors...)
}

// Create returns a builder for creating a ImportStatement entity.
func (c *ImportStatementClient) Create() *ImportStatementCreate {
	mutation := newImportStatementMutation(c.config, OpCreate)
	return &ImportStatementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImportStatement entities.
func (c *ImportStatementClient) CreateBulk(builders ...*ImportStatementCreate) *ImportStatementCreateBulk {
	return &ImportStatementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImportStatementClient) MapCreateBulk(slice any, setFunc func(*ImportStatementCreate, int)) *ImportStatementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImportStatementCreateBulk{err: fmt.Errorf("calling to ImportStatementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImportStatementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImportStatementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImportStatement.
func (c *ImportStatementClient) Update() *ImportStatementUpdate {
	mutation := newImportStatementMutation(c.config, OpUpdate)
	return &ImportStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImportStatementClient) UpdateOne(_m *ImportStatement) *ImportStatementUpdateOne {
	mutation := newImportStatementMutation(c.config, OpUpdateOne, withImportStatement(_m))
	return &ImportStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImportStatementClient) UpdateOneID(id int) *ImportStatementUpdateOne {
	mutation := newImportStatementMutation(c.config, OpUpdateOne, withImportStatementID(id))
	return &ImportStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImportStatement.
func (c *ImportStatementClient) Delete() *ImportStatementDelete {
	mutation := newImportStatementMutation(c.config, OpDelete)
	return &ImportStatementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImportStatementClient) DeleteOne(_m *ImportStatement) *ImportStatementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImportStatementClient) DeleteOneID(id int) *ImportStatementDeleteOne {
	builder := c.Delete().Where(importstatement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImportStatementDeleteOne{builder}
}

// Query returns a query builder for ImportStatement.
func (c *ImportStatementClient) Query() *ImportStatementQuery {
	return &ImportStatementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImportStatement},
		inters: c.Interceptors(),
	}
}

// Get returns a ImportStatement entity by its id.
func (c *ImportStatementClient) Get(ctx context.Context, id int) (*ImportStatement, error) {
	return c.Query().Where(importstatement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImportStatementClient) GetX(ctx context.Context, id int) *ImportStatement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a ImportStatement.
func (c *ImportStatementClient) QueryFile(_m *ImportStatement) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(importstatement.Table, importstatement.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, importstatement.FileTable, importstatement.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImportedSymbol queries the imported_symbol edge of a ImportStatement.
func (c *ImportStatementClient) QueryImportedSymbol(_m *ImportStatement) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(importstatement.Table, importstatement.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, importstatement.ImportedSymbolTable, importstatement.ImportedSymbolColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImportStatementClient) Hooks() []Hook {
	return c.hooks.ImportStatement
}

// Interceptors returns the client interceptors.
func (c *ImportStatementClient) Interceptors() []Interceptor {
	return c.inters.ImportStatement
}

func (c *ImportStatementClient) mutate(ctx context.Context, m *ImportStatementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImportStatementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImportStatementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImportStatementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImportStatementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImportStatement mutation op: %q", m.Op())
	}
}

// InheritanceRelationshipClient is a client for the InheritanceRelationship schema.
type InheritanceRelationshipClient struct {
	config
}

// NewInheritanceRelationshipClient returns a client for the InheritanceRelationship from the given config.
func NewInheritanceRelationshipClient(c config) *InheritanceRelationshipClient {
	return &InheritanceRelationshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inheritancerelationship.Hooks(f(g(h())))`.
func (c *InheritanceRelationshipClient) Use(hooks ...Hook) {
	c.hooks.InheritanceRelationship = append(c.hooks.InheritanceRelationship, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inheritancerelationship.Intercept(f(g(h())))`.
func (c *InheritanceRelationshipClient) Intercept(interceptors ...Interceptor) {
	c.inters.InheritanceRelationship = append(c.inters.InheritanceRelationship, interceptors...)
}

// Create returns a builder for creating a InheritanceRelationship entity.
func (c *InheritanceRelationshipClient) Create() *InheritanceRelationshipCreate {
	mutation := newInheritanceRelationshipMutation(c.config, OpCreate)
	return &InheritanceRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InheritanceRelationship entities.
func (c *InheritanceRelationshipClient) CreateBulk(builders ...*InheritanceRelationshipCreate) *InheritanceRelationshipCreateBulk {
	return &InheritanceRelationshipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InheritanceRelationshipClient) MapCreateBulk(slice any, setFunc func(*InheritanceRelationshipCreate, int)) *InheritanceRelationshipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InheritanceRelationshipCreateBulk{err: fmt.Errorf("calling to InheritanceRelationshipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InheritanceRelationshipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InheritanceRelationshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InheritanceRelationship.
func (c *InheritanceRelationshipClient) Update() *InheritanceRelationshipUpdate {
	mutation := newInheritanceRelationshipMutation(c.config, OpUpdate)
	return &InheritanceRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InheritanceRelationshipClient) UpdateOne(_m *InheritanceRelationship) *InheritanceRelationshipUpdateOne {
	mutation := newInheritanceRelationshipMutation(c.config, OpUpdateOne, withInheritanceRelationship(_m))
	return &InheritanceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InheritanceRelationshipClient) UpdateOneID(id int) *InheritanceRelationshipUpdateOne {
	mutation := newInheritanceRelationshipMutation(c.config, OpUpdateOne, withInheritanceRelationshipID(id))
	return &InheritanceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InheritanceRelationship.
func (c *InheritanceRelationshipClient) Delete() *InheritanceRelationshipDelete {
	mutation := newInheritanceRelationshipMutation(c.config, OpDelete)
	return &InheritanceRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InheritanceRelationshipClient) DeleteOne(_m *InheritanceRelationship) *InheritanceRelationshipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InheritanceRelationshipClient) DeleteOneID(id int) *InheritanceRelationshipDeleteOne {
	builder := c.Delete().Where(inheritancerelationship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InheritanceRelationshipDeleteOne{builder}
}

// Query returns a query builder for InheritanceRelationship.
func (c *InheritanceRelationshipClient) Query() *InheritanceRelationshipQuery {
	return &InheritanceRelationshipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInheritanceRelationship},
		inters: c.Interceptors(),
	}
}

// Get returns a InheritanceRelationship entity by its id.
func (c *InheritanceRelationshipClient) Get(ctx context.Context, id int) (*InheritanceRelationship, error) {
	return c.Query().Where(inheritancerelationship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InheritanceRelationshipClient) GetX(ctx context.Context, id int) *InheritanceRelationship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChild queries the child edge of a InheritanceRelationship.
func (c *InheritanceRelationshipClient) QueryChild(_m *InheritanceRelationship) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inheritancerelationship.Table, inheritancerelationship.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inheritancerelationship.ChildTable, inheritancerelationship.ChildColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a InheritanceRelationship.
func (c *InheritanceRelationshipClient) QueryParent(_m *InheritanceRelationship) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inheritancerelationship.Table, inheritancerelationship.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inheritancerelationship.ParentTable, inheritancerelationship.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a InheritanceRelationship.
func (c *InheritanceRelationshipClient) QueryFile(_m *InheritanceRelationship) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inheritancerelationship.Table, inheritancerelationship.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inheritancerelationship.FileTable, inheritancerelationship.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InheritanceRelationshipClient) Hooks() []Hook {
	return c.hooks.InheritanceRelationship
}

// Interceptors returns the client interceptors.
func (c *InheritanceRelationshipClient) Interceptors() []Interceptor {
	return c.inters.InheritanceRelationship
}

func (c *InheritanceRelationshipClient) mutate(ctx context.Context, m *InheritanceRelationshipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InheritanceRelationshipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InheritanceRelationshipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InheritanceRelationshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InheritanceRelationshipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InheritanceRelationship mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(_m *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(_m))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(_m *Project) *ProjectDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFiles queries the files edge of a Project.
func (c *ProjectClient) QueryFiles(_m *Project) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.FilesTable, project.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// SymbolClient is a client for the Symbol schema.
type SymbolClient struct {
	config
}

// NewSymbolClient returns a client for the Symbol from the given config.
func NewSymbolClient(c config) *SymbolClient {
	return &SymbolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `symbol.Hooks(f(g(h())))`.
func (c *SymbolClient) Use(hooks ...Hook) {
	c.hooks.Symbol = append(c.hooks.Symbol, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `symbol.Intercept(f(g(h())))`.
func (c *SymbolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Symbol = append(c.inters.Symbol, interceptors...)
}

// Create returns a builder for creating a Symbol entity.
func (c *SymbolClient) Create() *SymbolCreate {
	mutation := newSymbolMutation(c.config, OpCreate)
	return &SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Symbol entities.
func (c *SymbolClient) CreateBulk(builders ...*SymbolCreate) *SymbolCreateBulk {
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SymbolClient) MapCreateBulk(slice any, setFunc func(*SymbolCreate, int)) *SymbolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SymbolCreateBulk{err: fmt.Errorf("calling to SymbolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SymbolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SymbolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Symbol.
func (c *SymbolClient) Update() *SymbolUpdate {
	mutation := newSymbolMutation(c.config, OpUpdate)
	return &SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SymbolClient) UpdateOne(_m *Symbol) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbol(_m))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SymbolClient) UpdateOneID(id int) *SymbolUpdateOne {
	mutation := newSymbolMutation(c.config, OpUpdateOne, withSymbolID(id))
	return &SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Symbol.
func (c *SymbolClient) Delete() *SymbolDelete {
	mutation := newSymbolMutation(c.config, OpDelete)
	return &SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SymbolClient) DeleteOne(_m *Symbol) *SymbolDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SymbolClient) DeleteOneID(id int) *SymbolDeleteOne {
	builder := c.Delete().Where(symbol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SymbolDeleteOne{builder}
}

// Query returns a query builder for Symbol.
func (c *SymbolClient) Query() *SymbolQuery {
	return &SymbolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSymbol},
		inters: c.Interceptors(),
	}
}

// Get returns a Symbol entity by its id.
func (c *SymbolClient) Get(ctx context.Context, id int) (*Symbol, error) {
	return c.Query().Where(symbol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SymbolClient) GetX(ctx context.Context, id int) *Symbol {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFile queries the file edge of a Symbol.
func (c *SymbolClient) QueryFile(_m *Symbol) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, symbol.FileTable, symbol.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAstNode queries the ast_node edge of a Symbol.
func (c *SymbolClient) QueryAstNode(_m *Symbol) *ASTNodeQuery {
	query := (&ASTNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(astnode.Table, astnode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, symbol.AstNodeTable, symbol.AstNodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallsMade queries the calls_made edge of a Symbol.
func (c *SymbolClient) QueryCallsMade(_m *Symbol) *CallRelationshipQuery {
	query := (&CallRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(callrelationship.Table, callrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.CallsMadeTable, symbol.CallsMadeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallsReceived queries the calls_received edge of a Symbol.
func (c *SymbolClient) QueryCallsReceived(_m *Symbol) *CallRelationshipQuery {
	query := (&CallRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(callrelationship.Table, callrelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.CallsReceivedTable, symbol.CallsReceivedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReferences queries the references edge of a Symbol.
func (c *SymbolClient) QueryReferences(_m *Symbol) *SymbolReferenceQuery {
	query := (&SymbolReferenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(symbolreference.Table, symbolreference.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.ReferencesTable, symbol.ReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildClasses queries the child_classes edge of a Symbol.
func (c *SymbolClient) QueryChildClasses(_m *Symbol) *InheritanceRelationshipQuery {
	query := (&InheritanceRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(inheritancerelationship.Table, inheritancerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.ChildClassesTable, symbol.ChildClassesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentClasses queries the parent_classes edge of a Symbol.
func (c *SymbolClient) QueryParentClasses(_m *Symbol) *InheritanceRelationshipQuery {
	query := (&InheritanceRelationshipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(inheritancerelationship.Table, inheritancerelationship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.ParentClassesTable, symbol.ParentClassesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImportReferences queries the import_references edge of a Symbol.
func (c *SymbolClient) QueryImportReferences(_m *Symbol) *ImportStatementQuery {
	query := (&ImportStatementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbol.Table, symbol.FieldID, id),
			sqlgraph.To(importstatement.Table, importstatement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, symbol.ImportReferencesTable, symbol.ImportReferencesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SymbolClient) Hooks() []Hook {
	return c.hooks.Symbol
}

// Interceptors returns the client interceptors.
func (c *SymbolClient) Interceptors() []Interceptor {
	return c.inters.Symbol
}

func (c *SymbolClient) mutate(ctx context.Context, m *SymbolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SymbolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SymbolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SymbolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SymbolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Symbol mutation op: %q", m.Op())
	}
}

// SymbolReferenceClient is a client for the SymbolReference schema.
type SymbolReferenceClient struct {
	config
}

// NewSymbolReferenceClient returns a client for the SymbolReference from the given config.
func NewSymbolReferenceClient(c config) *SymbolReferenceClient {
	return &SymbolReferenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `symbolreference.Hooks(f(g(h())))`.
func (c *SymbolReferenceClient) Use(hooks ...Hook) {
	c.hooks.SymbolReference = append(c.hooks.SymbolReference, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `symbolreference.Intercept(f(g(h())))`.
func (c *SymbolReferenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.SymbolReference = append(c.inters.SymbolReference, interceptors...)
}

// Create returns a builder for creating a SymbolReference entity.
func (c *SymbolReferenceClient) Create() *SymbolReferenceCreate {
	mutation := newSymbolReferenceMutation(c.config, OpCreate)
	return &SymbolReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SymbolReference entities.
func (c *SymbolReferenceClient) CreateBulk(builders ...*SymbolReferenceCreate) *SymbolReferenceCreateBulk {
	return &SymbolReferenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SymbolReferenceClient) MapCreateBulk(slice any, setFunc func(*SymbolReferenceCreate, int)) *SymbolReferenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SymbolReferenceCreateBulk{err: fmt.Errorf("calling to SymbolReferenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SymbolReferenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SymbolReferenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SymbolReference.
func (c *SymbolReferenceClient) Update() *SymbolReferenceUpdate {
	mutation := newSymbolReferenceMutation(c.config, OpUpdate)
	return &SymbolReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SymbolReferenceClient) UpdateOne(_m *SymbolReference) *SymbolReferenceUpdateOne {
	mutation := newSymbolReferenceMutation(c.config, OpUpdateOne, withSymbolReference(_m))
	return &SymbolReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SymbolReferenceClient) UpdateOneID(id int) *SymbolReferenceUpdateOne {
	mutation := newSymbolReferenceMutation(c.config, OpUpdateOne, withSymbolReferenceID(id))
	return &SymbolReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SymbolReference.
func (c *SymbolReferenceClient) Delete() *SymbolReferenceDelete {
	mutation := newSymbolReferenceMutation(c.config, OpDelete)
	return &SymbolReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SymbolReferenceClient) DeleteOne(_m *SymbolReference) *SymbolReferenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SymbolReferenceClient) DeleteOneID(id int) *SymbolReferenceDeleteOne {
	builder := c.Delete().Where(symbolreference.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SymbolReferenceDeleteOne{builder}
}

// Query returns a query builder for SymbolReference.
func (c *SymbolReferenceClient) Query() *SymbolReferenceQuery {
	return &SymbolReferenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSymbolReference},
		inters: c.Interceptors(),
	}
}

// Get returns a SymbolReference entity by its id.
func (c *SymbolReferenceClient) Get(ctx context.Context, id int) (*SymbolReference, error) {
	return c.Query().Where(symbolreference.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SymbolReferenceClient) GetX(ctx context.Context, id int) *SymbolReference {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySymbol queries the symbol edge of a SymbolReference.
func (c *SymbolReferenceClient) QuerySymbol(_m *SymbolReference) *SymbolQuery {
	query := (&SymbolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbolreference.Table, symbolreference.FieldID, id),
			sqlgraph.To(symbol.Table, symbol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, symbolreference.SymbolTable, symbolreference.SymbolColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a SymbolReference.
func (c *SymbolReferenceClient) QueryFile(_m *SymbolReference) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbolreference.Table, symbolreference.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, symbolreference.FileTable, symbolreference.FileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContextNode queries the context_node edge of a SymbolReference.
func (c *SymbolReferenceClient) QueryContextNode(_m *SymbolReference) *ASTNodeQuery {
	query := (&ASTNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(symbolreference.Table, symbolreference.FieldID, id),
			sqlgraph.To(astnode.Table, astnode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, symbolreference.ContextNodeTable, symbolreference.ContextNodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SymbolReferenceClient) Hooks() []Hook {
	return c.hooks.SymbolReference
}

// Interceptors returns the client interceptors.
func (c *SymbolReferenceClient) Interceptors() []Interceptor {
	return c.inters.SymbolReference
}

func (c *SymbolReferenceClient) mutate(ctx context.Context, m *SymbolReferenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SymbolReferenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SymbolReferenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SymbolReferenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SymbolReferenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SymbolReference mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ASTNode, CallRelationship, File, ImportStatement, InheritanceRelationship,
		Project, Symbol, SymbolReference []ent.Hook
	}
	inters struct {
		ASTNode, CallRelationship, File, ImportStatement, InheritanceRelationship,
		Project, Symbol, SymbolReference []ent.Interceptor
	}
)
