// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/safedep/code/examples/astdb/ent/astnode"
	"github.com/safedep/code/examples/astdb/ent/callrelationship"
	"github.com/safedep/code/examples/astdb/ent/file"
	"github.com/safedep/code/examples/astdb/ent/importstatement"
	"github.com/safedep/code/examples/astdb/ent/inheritancerelationship"
	"github.com/safedep/code/examples/astdb/ent/predicate"
	"github.com/safedep/code/examples/astdb/ent/project"
	"github.com/safedep/code/examples/astdb/ent/symbol"
	"github.com/safedep/code/examples/astdb/ent/symbolreference"
)

// FileUpdate is the builder for updating File entities.
type FileUpdate struct {
	config
	hooks    []Hook
	mutation *FileMutation
}

// Where appends a list predicates to the FileUpdate builder.
func (_u *FileUpdate) Where(ps ...predicate.File) *FileUpdate {
	_u.mutation.Where(ps...)
	return _u
}

// SetRelativePath sets the "relative_path" field.
func (_u *FileUpdate) SetRelativePath(v string) *FileUpdate {
	_u.mutation.SetRelativePath(v)
	return _u
}

// SetNillableRelativePath sets the "relative_path" field if the given value is not nil.
func (_u *FileUpdate) SetNillableRelativePath(v *string) *FileUpdate {
	if v != nil {
		_u.SetRelativePath(*v)
	}
	return _u
}

// SetAbsolutePath sets the "absolute_path" field.
func (_u *FileUpdate) SetAbsolutePath(v string) *FileUpdate {
	_u.mutation.SetAbsolutePath(v)
	return _u
}

// SetNillableAbsolutePath sets the "absolute_path" field if the given value is not nil.
func (_u *FileUpdate) SetNillableAbsolutePath(v *string) *FileUpdate {
	if v != nil {
		_u.SetAbsolutePath(*v)
	}
	return _u
}

// SetLanguage sets the "language" field.
func (_u *FileUpdate) SetLanguage(v file.Language) *FileUpdate {
	_u.mutation.SetLanguage(v)
	return _u
}

// SetNillableLanguage sets the "language" field if the given value is not nil.
func (_u *FileUpdate) SetNillableLanguage(v *file.Language) *FileUpdate {
	if v != nil {
		_u.SetLanguage(*v)
	}
	return _u
}

// SetContentHash sets the "content_hash" field.
func (_u *FileUpdate) SetContentHash(v string) *FileUpdate {
	_u.mutation.SetContentHash(v)
	return _u
}

// SetNillableContentHash sets the "content_hash" field if the given value is not nil.
func (_u *FileUpdate) SetNillableContentHash(v *string) *FileUpdate {
	if v != nil {
		_u.SetContentHash(*v)
	}
	return _u
}

// SetSizeBytes sets the "size_bytes" field.
func (_u *FileUpdate) SetSizeBytes(v int) *FileUpdate {
	_u.mutation.ResetSizeBytes()
	_u.mutation.SetSizeBytes(v)
	return _u
}

// SetNillableSizeBytes sets the "size_bytes" field if the given value is not nil.
func (_u *FileUpdate) SetNillableSizeBytes(v *int) *FileUpdate {
	if v != nil {
		_u.SetSizeBytes(*v)
	}
	return _u
}

// AddSizeBytes adds value to the "size_bytes" field.
func (_u *FileUpdate) AddSizeBytes(v int) *FileUpdate {
	_u.mutation.AddSizeBytes(v)
	return _u
}

// SetLineCount sets the "line_count" field.
func (_u *FileUpdate) SetLineCount(v int) *FileUpdate {
	_u.mutation.ResetLineCount()
	_u.mutation.SetLineCount(v)
	return _u
}

// SetNillableLineCount sets the "line_count" field if the given value is not nil.
func (_u *FileUpdate) SetNillableLineCount(v *int) *FileUpdate {
	if v != nil {
		_u.SetLineCount(*v)
	}
	return _u
}

// AddLineCount adds value to the "line_count" field.
func (_u *FileUpdate) AddLineCount(v int) *FileUpdate {
	_u.mutation.AddLineCount(v)
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *FileUpdate) SetCreatedAt(v time.Time) *FileUpdate {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *FileUpdate) SetNillableCreatedAt(v *time.Time) *FileUpdate {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *FileUpdate) SetUpdatedAt(v time.Time) *FileUpdate {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetProjectID sets the "project" edge to the Project entity by ID.
func (_u *FileUpdate) SetProjectID(id int) *FileUpdate {
	_u.mutation.SetProjectID(id)
	return _u
}

// SetNillableProjectID sets the "project" edge to the Project entity by ID if the given value is not nil.
func (_u *FileUpdate) SetNillableProjectID(id *int) *FileUpdate {
	if id != nil {
		_u = _u.SetProjectID(*id)
	}
	return _u
}

// SetProject sets the "project" edge to the Project entity.
func (_u *FileUpdate) SetProject(v *Project) *FileUpdate {
	return _u.SetProjectID(v.ID)
}

// AddAstNodeIDs adds the "ast_nodes" edge to the ASTNode entity by IDs.
func (_u *FileUpdate) AddAstNodeIDs(ids ...int) *FileUpdate {
	_u.mutation.AddAstNodeIDs(ids...)
	return _u
}

// AddAstNodes adds the "ast_nodes" edges to the ASTNode entity.
func (_u *FileUpdate) AddAstNodes(v ...*ASTNode) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddAstNodeIDs(ids...)
}

// AddSymbolIDs adds the "symbols" edge to the Symbol entity by IDs.
func (_u *FileUpdate) AddSymbolIDs(ids ...int) *FileUpdate {
	_u.mutation.AddSymbolIDs(ids...)
	return _u
}

// AddSymbols adds the "symbols" edges to the Symbol entity.
func (_u *FileUpdate) AddSymbols(v ...*Symbol) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSymbolIDs(ids...)
}

// AddImportIDs adds the "imports" edge to the ImportStatement entity by IDs.
func (_u *FileUpdate) AddImportIDs(ids ...int) *FileUpdate {
	_u.mutation.AddImportIDs(ids...)
	return _u
}

// AddImports adds the "imports" edges to the ImportStatement entity.
func (_u *FileUpdate) AddImports(v ...*ImportStatement) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddImportIDs(ids...)
}

// AddCallSiteIDs adds the "call_sites" edge to the CallRelationship entity by IDs.
func (_u *FileUpdate) AddCallSiteIDs(ids ...int) *FileUpdate {
	_u.mutation.AddCallSiteIDs(ids...)
	return _u
}

// AddCallSites adds the "call_sites" edges to the CallRelationship entity.
func (_u *FileUpdate) AddCallSites(v ...*CallRelationship) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallSiteIDs(ids...)
}

// AddInheritanceSiteIDs adds the "inheritance_sites" edge to the InheritanceRelationship entity by IDs.
func (_u *FileUpdate) AddInheritanceSiteIDs(ids ...int) *FileUpdate {
	_u.mutation.AddInheritanceSiteIDs(ids...)
	return _u
}

// AddInheritanceSites adds the "inheritance_sites" edges to the InheritanceRelationship entity.
func (_u *FileUpdate) AddInheritanceSites(v ...*InheritanceRelationship) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddInheritanceSiteIDs(ids...)
}

// AddSymbolReferenceIDs adds the "symbol_references" edge to the SymbolReference entity by IDs.
func (_u *FileUpdate) AddSymbolReferenceIDs(ids ...int) *FileUpdate {
	_u.mutation.AddSymbolReferenceIDs(ids...)
	return _u
}

// AddSymbolReferences adds the "symbol_references" edges to the SymbolReference entity.
func (_u *FileUpdate) AddSymbolReferences(v ...*SymbolReference) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSymbolReferenceIDs(ids...)
}

// Mutation returns the FileMutation object of the builder.
func (_u *FileUpdate) Mutation() *FileMutation {
	return _u.mutation
}

// ClearProject clears the "project" edge to the Project entity.
func (_u *FileUpdate) ClearProject() *FileUpdate {
	_u.mutation.ClearProject()
	return _u
}

// ClearAstNodes clears all "ast_nodes" edges to the ASTNode entity.
func (_u *FileUpdate) ClearAstNodes() *FileUpdate {
	_u.mutation.ClearAstNodes()
	return _u
}

// RemoveAstNodeIDs removes the "ast_nodes" edge to ASTNode entities by IDs.
func (_u *FileUpdate) RemoveAstNodeIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveAstNodeIDs(ids...)
	return _u
}

// RemoveAstNodes removes "ast_nodes" edges to ASTNode entities.
func (_u *FileUpdate) RemoveAstNodes(v ...*ASTNode) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveAstNodeIDs(ids...)
}

// ClearSymbols clears all "symbols" edges to the Symbol entity.
func (_u *FileUpdate) ClearSymbols() *FileUpdate {
	_u.mutation.ClearSymbols()
	return _u
}

// RemoveSymbolIDs removes the "symbols" edge to Symbol entities by IDs.
func (_u *FileUpdate) RemoveSymbolIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveSymbolIDs(ids...)
	return _u
}

// RemoveSymbols removes "symbols" edges to Symbol entities.
func (_u *FileUpdate) RemoveSymbols(v ...*Symbol) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSymbolIDs(ids...)
}

// ClearImports clears all "imports" edges to the ImportStatement entity.
func (_u *FileUpdate) ClearImports() *FileUpdate {
	_u.mutation.ClearImports()
	return _u
}

// RemoveImportIDs removes the "imports" edge to ImportStatement entities by IDs.
func (_u *FileUpdate) RemoveImportIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveImportIDs(ids...)
	return _u
}

// RemoveImports removes "imports" edges to ImportStatement entities.
func (_u *FileUpdate) RemoveImports(v ...*ImportStatement) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveImportIDs(ids...)
}

// ClearCallSites clears all "call_sites" edges to the CallRelationship entity.
func (_u *FileUpdate) ClearCallSites() *FileUpdate {
	_u.mutation.ClearCallSites()
	return _u
}

// RemoveCallSiteIDs removes the "call_sites" edge to CallRelationship entities by IDs.
func (_u *FileUpdate) RemoveCallSiteIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveCallSiteIDs(ids...)
	return _u
}

// RemoveCallSites removes "call_sites" edges to CallRelationship entities.
func (_u *FileUpdate) RemoveCallSites(v ...*CallRelationship) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallSiteIDs(ids...)
}

// ClearInheritanceSites clears all "inheritance_sites" edges to the InheritanceRelationship entity.
func (_u *FileUpdate) ClearInheritanceSites() *FileUpdate {
	_u.mutation.ClearInheritanceSites()
	return _u
}

// RemoveInheritanceSiteIDs removes the "inheritance_sites" edge to InheritanceRelationship entities by IDs.
func (_u *FileUpdate) RemoveInheritanceSiteIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveInheritanceSiteIDs(ids...)
	return _u
}

// RemoveInheritanceSites removes "inheritance_sites" edges to InheritanceRelationship entities.
func (_u *FileUpdate) RemoveInheritanceSites(v ...*InheritanceRelationship) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveInheritanceSiteIDs(ids...)
}

// ClearSymbolReferences clears all "symbol_references" edges to the SymbolReference entity.
func (_u *FileUpdate) ClearSymbolReferences() *FileUpdate {
	_u.mutation.ClearSymbolReferences()
	return _u
}

// RemoveSymbolReferenceIDs removes the "symbol_references" edge to SymbolReference entities by IDs.
func (_u *FileUpdate) RemoveSymbolReferenceIDs(ids ...int) *FileUpdate {
	_u.mutation.RemoveSymbolReferenceIDs(ids...)
	return _u
}

// RemoveSymbolReferences removes "symbol_references" edges to SymbolReference entities.
func (_u *FileUpdate) RemoveSymbolReferences(v ...*SymbolReference) *FileUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSymbolReferenceIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *FileUpdate) Save(ctx context.Context) (int, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *FileUpdate) SaveX(ctx context.Context) int {
	affected, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (_u *FileUpdate) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *FileUpdate) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *FileUpdate) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := file.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *FileUpdate) check() error {
	if v, ok := _u.mutation.RelativePath(); ok {
		if err := file.RelativePathValidator(v); err != nil {
			return &ValidationError{Name: "relative_path", err: fmt.Errorf(`ent: validator failed for field "File.relative_path": %w`, err)}
		}
	}
	if v, ok := _u.mutation.AbsolutePath(); ok {
		if err := file.AbsolutePathValidator(v); err != nil {
			return &ValidationError{Name: "absolute_path", err: fmt.Errorf(`ent: validator failed for field "File.absolute_path": %w`, err)}
		}
	}
	if v, ok := _u.mutation.Language(); ok {
		if err := file.LanguageValidator(v); err != nil {
			return &ValidationError{Name: "language", err: fmt.Errorf(`ent: validator failed for field "File.language": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ContentHash(); ok {
		if err := file.ContentHashValidator(v); err != nil {
			return &ValidationError{Name: "content_hash", err: fmt.Errorf(`ent: validator failed for field "File.content_hash": %w`, err)}
		}
	}
	if v, ok := _u.mutation.SizeBytes(); ok {
		if err := file.SizeBytesValidator(v); err != nil {
			return &ValidationError{Name: "size_bytes", err: fmt.Errorf(`ent: validator failed for field "File.size_bytes": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LineCount(); ok {
		if err := file.LineCountValidator(v); err != nil {
			return &ValidationError{Name: "line_count", err: fmt.Errorf(`ent: validator failed for field "File.line_count": %w`, err)}
		}
	}
	return nil
}

func (_u *FileUpdate) sqlSave(ctx context.Context) (_node int, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(file.Table, file.Columns, sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt))
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.RelativePath(); ok {
		_spec.SetField(file.FieldRelativePath, field.TypeString, value)
	}
	if value, ok := _u.mutation.AbsolutePath(); ok {
		_spec.SetField(file.FieldAbsolutePath, field.TypeString, value)
	}
	if value, ok := _u.mutation.Language(); ok {
		_spec.SetField(file.FieldLanguage, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.ContentHash(); ok {
		_spec.SetField(file.FieldContentHash, field.TypeString, value)
	}
	if value, ok := _u.mutation.SizeBytes(); ok {
		_spec.SetField(file.FieldSizeBytes, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedSizeBytes(); ok {
		_spec.AddField(file.FieldSizeBytes, field.TypeInt, value)
	}
	if value, ok := _u.mutation.LineCount(); ok {
		_spec.SetField(file.FieldLineCount, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedLineCount(); ok {
		_spec.AddField(file.FieldLineCount, field.TypeInt, value)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(file.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(file.FieldUpdatedAt, field.TypeTime, value)
	}
	if _u.mutation.ProjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.ProjectTable,
			Columns: []string{file.ProjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ProjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.ProjectTable,
			Columns: []string{file.ProjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.AstNodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedAstNodesIDs(); len(nodes) > 0 && !_u.mutation.AstNodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.AstNodesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SymbolsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSymbolsIDs(); len(nodes) > 0 && !_u.mutation.SymbolsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SymbolsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ImportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedImportsIDs(); len(nodes) > 0 && !_u.mutation.ImportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ImportsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallSitesIDs(); len(nodes) > 0 && !_u.mutation.CallSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallSitesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.InheritanceSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedInheritanceSitesIDs(); len(nodes) > 0 && !_u.mutation.InheritanceSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.InheritanceSitesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SymbolReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSymbolReferencesIDs(); len(nodes) > 0 && !_u.mutation.SymbolReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SymbolReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{file.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	_u.mutation.done = true
	return _node, nil
}

// FileUpdateOne is the builder for updating a single File entity.
type FileUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *FileMutation
}

// SetRelativePath sets the "relative_path" field.
func (_u *FileUpdateOne) SetRelativePath(v string) *FileUpdateOne {
	_u.mutation.SetRelativePath(v)
	return _u
}

// SetNillableRelativePath sets the "relative_path" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableRelativePath(v *string) *FileUpdateOne {
	if v != nil {
		_u.SetRelativePath(*v)
	}
	return _u
}

// SetAbsolutePath sets the "absolute_path" field.
func (_u *FileUpdateOne) SetAbsolutePath(v string) *FileUpdateOne {
	_u.mutation.SetAbsolutePath(v)
	return _u
}

// SetNillableAbsolutePath sets the "absolute_path" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableAbsolutePath(v *string) *FileUpdateOne {
	if v != nil {
		_u.SetAbsolutePath(*v)
	}
	return _u
}

// SetLanguage sets the "language" field.
func (_u *FileUpdateOne) SetLanguage(v file.Language) *FileUpdateOne {
	_u.mutation.SetLanguage(v)
	return _u
}

// SetNillableLanguage sets the "language" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableLanguage(v *file.Language) *FileUpdateOne {
	if v != nil {
		_u.SetLanguage(*v)
	}
	return _u
}

// SetContentHash sets the "content_hash" field.
func (_u *FileUpdateOne) SetContentHash(v string) *FileUpdateOne {
	_u.mutation.SetContentHash(v)
	return _u
}

// SetNillableContentHash sets the "content_hash" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableContentHash(v *string) *FileUpdateOne {
	if v != nil {
		_u.SetContentHash(*v)
	}
	return _u
}

// SetSizeBytes sets the "size_bytes" field.
func (_u *FileUpdateOne) SetSizeBytes(v int) *FileUpdateOne {
	_u.mutation.ResetSizeBytes()
	_u.mutation.SetSizeBytes(v)
	return _u
}

// SetNillableSizeBytes sets the "size_bytes" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableSizeBytes(v *int) *FileUpdateOne {
	if v != nil {
		_u.SetSizeBytes(*v)
	}
	return _u
}

// AddSizeBytes adds value to the "size_bytes" field.
func (_u *FileUpdateOne) AddSizeBytes(v int) *FileUpdateOne {
	_u.mutation.AddSizeBytes(v)
	return _u
}

// SetLineCount sets the "line_count" field.
func (_u *FileUpdateOne) SetLineCount(v int) *FileUpdateOne {
	_u.mutation.ResetLineCount()
	_u.mutation.SetLineCount(v)
	return _u
}

// SetNillableLineCount sets the "line_count" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableLineCount(v *int) *FileUpdateOne {
	if v != nil {
		_u.SetLineCount(*v)
	}
	return _u
}

// AddLineCount adds value to the "line_count" field.
func (_u *FileUpdateOne) AddLineCount(v int) *FileUpdateOne {
	_u.mutation.AddLineCount(v)
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *FileUpdateOne) SetCreatedAt(v time.Time) *FileUpdateOne {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *FileUpdateOne) SetNillableCreatedAt(v *time.Time) *FileUpdateOne {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *FileUpdateOne) SetUpdatedAt(v time.Time) *FileUpdateOne {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetProjectID sets the "project" edge to the Project entity by ID.
func (_u *FileUpdateOne) SetProjectID(id int) *FileUpdateOne {
	_u.mutation.SetProjectID(id)
	return _u
}

// SetNillableProjectID sets the "project" edge to the Project entity by ID if the given value is not nil.
func (_u *FileUpdateOne) SetNillableProjectID(id *int) *FileUpdateOne {
	if id != nil {
		_u = _u.SetProjectID(*id)
	}
	return _u
}

// SetProject sets the "project" edge to the Project entity.
func (_u *FileUpdateOne) SetProject(v *Project) *FileUpdateOne {
	return _u.SetProjectID(v.ID)
}

// AddAstNodeIDs adds the "ast_nodes" edge to the ASTNode entity by IDs.
func (_u *FileUpdateOne) AddAstNodeIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddAstNodeIDs(ids...)
	return _u
}

// AddAstNodes adds the "ast_nodes" edges to the ASTNode entity.
func (_u *FileUpdateOne) AddAstNodes(v ...*ASTNode) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddAstNodeIDs(ids...)
}

// AddSymbolIDs adds the "symbols" edge to the Symbol entity by IDs.
func (_u *FileUpdateOne) AddSymbolIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddSymbolIDs(ids...)
	return _u
}

// AddSymbols adds the "symbols" edges to the Symbol entity.
func (_u *FileUpdateOne) AddSymbols(v ...*Symbol) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSymbolIDs(ids...)
}

// AddImportIDs adds the "imports" edge to the ImportStatement entity by IDs.
func (_u *FileUpdateOne) AddImportIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddImportIDs(ids...)
	return _u
}

// AddImports adds the "imports" edges to the ImportStatement entity.
func (_u *FileUpdateOne) AddImports(v ...*ImportStatement) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddImportIDs(ids...)
}

// AddCallSiteIDs adds the "call_sites" edge to the CallRelationship entity by IDs.
func (_u *FileUpdateOne) AddCallSiteIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddCallSiteIDs(ids...)
	return _u
}

// AddCallSites adds the "call_sites" edges to the CallRelationship entity.
func (_u *FileUpdateOne) AddCallSites(v ...*CallRelationship) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallSiteIDs(ids...)
}

// AddInheritanceSiteIDs adds the "inheritance_sites" edge to the InheritanceRelationship entity by IDs.
func (_u *FileUpdateOne) AddInheritanceSiteIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddInheritanceSiteIDs(ids...)
	return _u
}

// AddInheritanceSites adds the "inheritance_sites" edges to the InheritanceRelationship entity.
func (_u *FileUpdateOne) AddInheritanceSites(v ...*InheritanceRelationship) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddInheritanceSiteIDs(ids...)
}

// AddSymbolReferenceIDs adds the "symbol_references" edge to the SymbolReference entity by IDs.
func (_u *FileUpdateOne) AddSymbolReferenceIDs(ids ...int) *FileUpdateOne {
	_u.mutation.AddSymbolReferenceIDs(ids...)
	return _u
}

// AddSymbolReferences adds the "symbol_references" edges to the SymbolReference entity.
func (_u *FileUpdateOne) AddSymbolReferences(v ...*SymbolReference) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSymbolReferenceIDs(ids...)
}

// Mutation returns the FileMutation object of the builder.
func (_u *FileUpdateOne) Mutation() *FileMutation {
	return _u.mutation
}

// ClearProject clears the "project" edge to the Project entity.
func (_u *FileUpdateOne) ClearProject() *FileUpdateOne {
	_u.mutation.ClearProject()
	return _u
}

// ClearAstNodes clears all "ast_nodes" edges to the ASTNode entity.
func (_u *FileUpdateOne) ClearAstNodes() *FileUpdateOne {
	_u.mutation.ClearAstNodes()
	return _u
}

// RemoveAstNodeIDs removes the "ast_nodes" edge to ASTNode entities by IDs.
func (_u *FileUpdateOne) RemoveAstNodeIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveAstNodeIDs(ids...)
	return _u
}

// RemoveAstNodes removes "ast_nodes" edges to ASTNode entities.
func (_u *FileUpdateOne) RemoveAstNodes(v ...*ASTNode) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveAstNodeIDs(ids...)
}

// ClearSymbols clears all "symbols" edges to the Symbol entity.
func (_u *FileUpdateOne) ClearSymbols() *FileUpdateOne {
	_u.mutation.ClearSymbols()
	return _u
}

// RemoveSymbolIDs removes the "symbols" edge to Symbol entities by IDs.
func (_u *FileUpdateOne) RemoveSymbolIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveSymbolIDs(ids...)
	return _u
}

// RemoveSymbols removes "symbols" edges to Symbol entities.
func (_u *FileUpdateOne) RemoveSymbols(v ...*Symbol) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSymbolIDs(ids...)
}

// ClearImports clears all "imports" edges to the ImportStatement entity.
func (_u *FileUpdateOne) ClearImports() *FileUpdateOne {
	_u.mutation.ClearImports()
	return _u
}

// RemoveImportIDs removes the "imports" edge to ImportStatement entities by IDs.
func (_u *FileUpdateOne) RemoveImportIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveImportIDs(ids...)
	return _u
}

// RemoveImports removes "imports" edges to ImportStatement entities.
func (_u *FileUpdateOne) RemoveImports(v ...*ImportStatement) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveImportIDs(ids...)
}

// ClearCallSites clears all "call_sites" edges to the CallRelationship entity.
func (_u *FileUpdateOne) ClearCallSites() *FileUpdateOne {
	_u.mutation.ClearCallSites()
	return _u
}

// RemoveCallSiteIDs removes the "call_sites" edge to CallRelationship entities by IDs.
func (_u *FileUpdateOne) RemoveCallSiteIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveCallSiteIDs(ids...)
	return _u
}

// RemoveCallSites removes "call_sites" edges to CallRelationship entities.
func (_u *FileUpdateOne) RemoveCallSites(v ...*CallRelationship) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallSiteIDs(ids...)
}

// ClearInheritanceSites clears all "inheritance_sites" edges to the InheritanceRelationship entity.
func (_u *FileUpdateOne) ClearInheritanceSites() *FileUpdateOne {
	_u.mutation.ClearInheritanceSites()
	return _u
}

// RemoveInheritanceSiteIDs removes the "inheritance_sites" edge to InheritanceRelationship entities by IDs.
func (_u *FileUpdateOne) RemoveInheritanceSiteIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveInheritanceSiteIDs(ids...)
	return _u
}

// RemoveInheritanceSites removes "inheritance_sites" edges to InheritanceRelationship entities.
func (_u *FileUpdateOne) RemoveInheritanceSites(v ...*InheritanceRelationship) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveInheritanceSiteIDs(ids...)
}

// ClearSymbolReferences clears all "symbol_references" edges to the SymbolReference entity.
func (_u *FileUpdateOne) ClearSymbolReferences() *FileUpdateOne {
	_u.mutation.ClearSymbolReferences()
	return _u
}

// RemoveSymbolReferenceIDs removes the "symbol_references" edge to SymbolReference entities by IDs.
func (_u *FileUpdateOne) RemoveSymbolReferenceIDs(ids ...int) *FileUpdateOne {
	_u.mutation.RemoveSymbolReferenceIDs(ids...)
	return _u
}

// RemoveSymbolReferences removes "symbol_references" edges to SymbolReference entities.
func (_u *FileUpdateOne) RemoveSymbolReferences(v ...*SymbolReference) *FileUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSymbolReferenceIDs(ids...)
}

// Where appends a list predicates to the FileUpdate builder.
func (_u *FileUpdateOne) Where(ps ...predicate.File) *FileUpdateOne {
	_u.mutation.Where(ps...)
	return _u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *FileUpdateOne) Select(field string, fields ...string) *FileUpdateOne {
	_u.fields = append([]string{field}, fields...)
	return _u
}

// Save executes the query and returns the updated File entity.
func (_u *FileUpdateOne) Save(ctx context.Context) (*File, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *FileUpdateOne) SaveX(ctx context.Context) *File {
	node, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (_u *FileUpdateOne) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *FileUpdateOne) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *FileUpdateOne) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := file.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *FileUpdateOne) check() error {
	if v, ok := _u.mutation.RelativePath(); ok {
		if err := file.RelativePathValidator(v); err != nil {
			return &ValidationError{Name: "relative_path", err: fmt.Errorf(`ent: validator failed for field "File.relative_path": %w`, err)}
		}
	}
	if v, ok := _u.mutation.AbsolutePath(); ok {
		if err := file.AbsolutePathValidator(v); err != nil {
			return &ValidationError{Name: "absolute_path", err: fmt.Errorf(`ent: validator failed for field "File.absolute_path": %w`, err)}
		}
	}
	if v, ok := _u.mutation.Language(); ok {
		if err := file.LanguageValidator(v); err != nil {
			return &ValidationError{Name: "language", err: fmt.Errorf(`ent: validator failed for field "File.language": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ContentHash(); ok {
		if err := file.ContentHashValidator(v); err != nil {
			return &ValidationError{Name: "content_hash", err: fmt.Errorf(`ent: validator failed for field "File.content_hash": %w`, err)}
		}
	}
	if v, ok := _u.mutation.SizeBytes(); ok {
		if err := file.SizeBytesValidator(v); err != nil {
			return &ValidationError{Name: "size_bytes", err: fmt.Errorf(`ent: validator failed for field "File.size_bytes": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LineCount(); ok {
		if err := file.LineCountValidator(v); err != nil {
			return &ValidationError{Name: "line_count", err: fmt.Errorf(`ent: validator failed for field "File.line_count": %w`, err)}
		}
	}
	return nil
}

func (_u *FileUpdateOne) sqlSave(ctx context.Context) (_node *File, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(file.Table, file.Columns, sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt))
	id, ok := _u.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "File.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := _u.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, file.FieldID)
		for _, f := range fields {
			if !file.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != file.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.RelativePath(); ok {
		_spec.SetField(file.FieldRelativePath, field.TypeString, value)
	}
	if value, ok := _u.mutation.AbsolutePath(); ok {
		_spec.SetField(file.FieldAbsolutePath, field.TypeString, value)
	}
	if value, ok := _u.mutation.Language(); ok {
		_spec.SetField(file.FieldLanguage, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.ContentHash(); ok {
		_spec.SetField(file.FieldContentHash, field.TypeString, value)
	}
	if value, ok := _u.mutation.SizeBytes(); ok {
		_spec.SetField(file.FieldSizeBytes, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedSizeBytes(); ok {
		_spec.AddField(file.FieldSizeBytes, field.TypeInt, value)
	}
	if value, ok := _u.mutation.LineCount(); ok {
		_spec.SetField(file.FieldLineCount, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedLineCount(); ok {
		_spec.AddField(file.FieldLineCount, field.TypeInt, value)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(file.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(file.FieldUpdatedAt, field.TypeTime, value)
	}
	if _u.mutation.ProjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.ProjectTable,
			Columns: []string{file.ProjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ProjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   file.ProjectTable,
			Columns: []string{file.ProjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.AstNodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedAstNodesIDs(); len(nodes) > 0 && !_u.mutation.AstNodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.AstNodesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.AstNodesTable,
			Columns: []string{file.AstNodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SymbolsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSymbolsIDs(); len(nodes) > 0 && !_u.mutation.SymbolsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SymbolsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolsTable,
			Columns: []string{file.SymbolsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ImportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedImportsIDs(); len(nodes) > 0 && !_u.mutation.ImportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ImportsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.ImportsTable,
			Columns: []string{file.ImportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallSitesIDs(); len(nodes) > 0 && !_u.mutation.CallSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallSitesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.CallSitesTable,
			Columns: []string{file.CallSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.InheritanceSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedInheritanceSitesIDs(); len(nodes) > 0 && !_u.mutation.InheritanceSitesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.InheritanceSitesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.InheritanceSitesTable,
			Columns: []string{file.InheritanceSitesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SymbolReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSymbolReferencesIDs(); len(nodes) > 0 && !_u.mutation.SymbolReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SymbolReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   file.SymbolReferencesTable,
			Columns: []string{file.SymbolReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &File{config: _u.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{file.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	_u.mutation.done = true
	return _node, nil
}
