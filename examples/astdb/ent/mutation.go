// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/safedep/code/examples/astdb/ent/astnode"
	"github.com/safedep/code/examples/astdb/ent/callrelationship"
	"github.com/safedep/code/examples/astdb/ent/file"
	"github.com/safedep/code/examples/astdb/ent/importstatement"
	"github.com/safedep/code/examples/astdb/ent/inheritancerelationship"
	"github.com/safedep/code/examples/astdb/ent/predicate"
	"github.com/safedep/code/examples/astdb/ent/project"
	"github.com/safedep/code/examples/astdb/ent/symbol"
	"github.com/safedep/code/examples/astdb/ent/symbolreference"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeASTNode                 = "ASTNode"
	TypeCallRelationship        = "CallRelationship"
	TypeFile                    = "File"
	TypeImportStatement         = "ImportStatement"
	TypeInheritanceRelationship = "InheritanceRelationship"
	TypeProject                 = "Project"
	TypeSymbol                  = "Symbol"
	TypeSymbolReference         = "SymbolReference"
)

// ASTNodeMutation represents an operation that mutates the ASTNode nodes in the graph.
type ASTNodeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	node_type         *astnode.NodeType
	name              *string
	qualified_name    *string
	start_line        *int
	addstart_line     *int
	end_line          *int
	addend_line       *int
	start_column      *int
	addstart_column   *int
	end_column        *int
	addend_column     *int
	content           *string
	tree_sitter_type  *string
	metadata          *map[string]interface{}
	created_at        *time.Time
	clearedFields     map[string]struct{}
	file              *int
	clearedfile       bool
	children          map[int]struct{}
	removedchildren   map[int]struct{}
	clearedchildren   bool
	parent            *int
	clearedparent     bool
	symbol            *int
	clearedsymbol     bool
	references        map[int]struct{}
	removedreferences map[int]struct{}
	clearedreferences bool
	done              bool
	oldValue          func(context.Context) (*ASTNode, error)
	predicates        []predicate.ASTNode
}

var _ ent.Mutation = (*ASTNodeMutation)(nil)

// astnodeOption allows management of the mutation configuration using functional options.
type astnodeOption func(*ASTNodeMutation)

// newASTNodeMutation creates new mutation for the ASTNode entity.
func newASTNodeMutation(c config, op Op, opts ...astnodeOption) *ASTNodeMutation {
	m := &ASTNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeASTNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withASTNodeID sets the ID field of the mutation.
func withASTNodeID(id int) astnodeOption {
	return func(m *ASTNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *ASTNode
		)
		m.oldValue = func(ctx context.Context) (*ASTNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ASTNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withASTNode sets the old ASTNode of the mutation.
func withASTNode(node *ASTNode) astnodeOption {
	return func(m *ASTNodeMutation) {
		m.oldValue = func(context.Context) (*ASTNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ASTNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ASTNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ASTNodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ASTNodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ASTNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeType sets the "node_type" field.
func (m *ASTNodeMutation) SetNodeType(at astnode.NodeType) {
	m.node_type = &at
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *ASTNodeMutation) NodeType() (r astnode.NodeType, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldNodeType(ctx context.Context) (v astnode.NodeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *ASTNodeMutation) ResetNodeType() {
	m.node_type = nil
}

// SetName sets the "name" field.
func (m *ASTNodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ASTNodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ASTNodeMutation) ClearName() {
	m.name = nil
	m.clearedFields[astnode.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ASTNodeMutation) NameCleared() bool {
	_, ok := m.clearedFields[astnode.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ASTNodeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, astnode.FieldName)
}

// SetQualifiedName sets the "qualified_name" field.
func (m *ASTNodeMutation) SetQualifiedName(s string) {
	m.qualified_name = &s
}

// QualifiedName returns the value of the "qualified_name" field in the mutation.
func (m *ASTNodeMutation) QualifiedName() (r string, exists bool) {
	v := m.qualified_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiedName returns the old "qualified_name" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldQualifiedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiedName: %w", err)
	}
	return oldValue.QualifiedName, nil
}

// ClearQualifiedName clears the value of the "qualified_name" field.
func (m *ASTNodeMutation) ClearQualifiedName() {
	m.qualified_name = nil
	m.clearedFields[astnode.FieldQualifiedName] = struct{}{}
}

// QualifiedNameCleared returns if the "qualified_name" field was cleared in this mutation.
func (m *ASTNodeMutation) QualifiedNameCleared() bool {
	_, ok := m.clearedFields[astnode.FieldQualifiedName]
	return ok
}

// ResetQualifiedName resets all changes to the "qualified_name" field.
func (m *ASTNodeMutation) ResetQualifiedName() {
	m.qualified_name = nil
	delete(m.clearedFields, astnode.FieldQualifiedName)
}

// SetStartLine sets the "start_line" field.
func (m *ASTNodeMutation) SetStartLine(i int) {
	m.start_line = &i
	m.addstart_line = nil
}

// StartLine returns the value of the "start_line" field in the mutation.
func (m *ASTNodeMutation) StartLine() (r int, exists bool) {
	v := m.start_line
	if v == nil {
		return
	}
	return *v, true
}

// OldStartLine returns the old "start_line" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldStartLine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartLine: %w", err)
	}
	return oldValue.StartLine, nil
}

// AddStartLine adds i to the "start_line" field.
func (m *ASTNodeMutation) AddStartLine(i int) {
	if m.addstart_line != nil {
		*m.addstart_line += i
	} else {
		m.addstart_line = &i
	}
}

// AddedStartLine returns the value that was added to the "start_line" field in this mutation.
func (m *ASTNodeMutation) AddedStartLine() (r int, exists bool) {
	v := m.addstart_line
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartLine resets all changes to the "start_line" field.
func (m *ASTNodeMutation) ResetStartLine() {
	m.start_line = nil
	m.addstart_line = nil
}

// SetEndLine sets the "end_line" field.
func (m *ASTNodeMutation) SetEndLine(i int) {
	m.end_line = &i
	m.addend_line = nil
}

// EndLine returns the value of the "end_line" field in the mutation.
func (m *ASTNodeMutation) EndLine() (r int, exists bool) {
	v := m.end_line
	if v == nil {
		return
	}
	return *v, true
}

// OldEndLine returns the old "end_line" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldEndLine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndLine: %w", err)
	}
	return oldValue.EndLine, nil
}

// AddEndLine adds i to the "end_line" field.
func (m *ASTNodeMutation) AddEndLine(i int) {
	if m.addend_line != nil {
		*m.addend_line += i
	} else {
		m.addend_line = &i
	}
}

// AddedEndLine returns the value that was added to the "end_line" field in this mutation.
func (m *ASTNodeMutation) AddedEndLine() (r int, exists bool) {
	v := m.addend_line
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndLine resets all changes to the "end_line" field.
func (m *ASTNodeMutation) ResetEndLine() {
	m.end_line = nil
	m.addend_line = nil
}

// SetStartColumn sets the "start_column" field.
func (m *ASTNodeMutation) SetStartColumn(i int) {
	m.start_column = &i
	m.addstart_column = nil
}

// StartColumn returns the value of the "start_column" field in the mutation.
func (m *ASTNodeMutation) StartColumn() (r int, exists bool) {
	v := m.start_column
	if v == nil {
		return
	}
	return *v, true
}

// OldStartColumn returns the old "start_column" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldStartColumn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartColumn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartColumn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartColumn: %w", err)
	}
	return oldValue.StartColumn, nil
}

// AddStartColumn adds i to the "start_column" field.
func (m *ASTNodeMutation) AddStartColumn(i int) {
	if m.addstart_column != nil {
		*m.addstart_column += i
	} else {
		m.addstart_column = &i
	}
}

// AddedStartColumn returns the value that was added to the "start_column" field in this mutation.
func (m *ASTNodeMutation) AddedStartColumn() (r int, exists bool) {
	v := m.addstart_column
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartColumn resets all changes to the "start_column" field.
func (m *ASTNodeMutation) ResetStartColumn() {
	m.start_column = nil
	m.addstart_column = nil
}

// SetEndColumn sets the "end_column" field.
func (m *ASTNodeMutation) SetEndColumn(i int) {
	m.end_column = &i
	m.addend_column = nil
}

// EndColumn returns the value of the "end_column" field in the mutation.
func (m *ASTNodeMutation) EndColumn() (r int, exists bool) {
	v := m.end_column
	if v == nil {
		return
	}
	return *v, true
}

// OldEndColumn returns the old "end_column" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldEndColumn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndColumn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndColumn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndColumn: %w", err)
	}
	return oldValue.EndColumn, nil
}

// AddEndColumn adds i to the "end_column" field.
func (m *ASTNodeMutation) AddEndColumn(i int) {
	if m.addend_column != nil {
		*m.addend_column += i
	} else {
		m.addend_column = &i
	}
}

// AddedEndColumn returns the value that was added to the "end_column" field in this mutation.
func (m *ASTNodeMutation) AddedEndColumn() (r int, exists bool) {
	v := m.addend_column
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndColumn resets all changes to the "end_column" field.
func (m *ASTNodeMutation) ResetEndColumn() {
	m.end_column = nil
	m.addend_column = nil
}

// SetContent sets the "content" field.
func (m *ASTNodeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ASTNodeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ASTNodeMutation) ClearContent() {
	m.content = nil
	m.clearedFields[astnode.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ASTNodeMutation) ContentCleared() bool {
	_, ok := m.clearedFields[astnode.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ASTNodeMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, astnode.FieldContent)
}

// SetTreeSitterType sets the "tree_sitter_type" field.
func (m *ASTNodeMutation) SetTreeSitterType(s string) {
	m.tree_sitter_type = &s
}

// TreeSitterType returns the value of the "tree_sitter_type" field in the mutation.
func (m *ASTNodeMutation) TreeSitterType() (r string, exists bool) {
	v := m.tree_sitter_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTreeSitterType returns the old "tree_sitter_type" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldTreeSitterType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTreeSitterType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTreeSitterType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreeSitterType: %w", err)
	}
	return oldValue.TreeSitterType, nil
}

// ClearTreeSitterType clears the value of the "tree_sitter_type" field.
func (m *ASTNodeMutation) ClearTreeSitterType() {
	m.tree_sitter_type = nil
	m.clearedFields[astnode.FieldTreeSitterType] = struct{}{}
}

// TreeSitterTypeCleared returns if the "tree_sitter_type" field was cleared in this mutation.
func (m *ASTNodeMutation) TreeSitterTypeCleared() bool {
	_, ok := m.clearedFields[astnode.FieldTreeSitterType]
	return ok
}

// ResetTreeSitterType resets all changes to the "tree_sitter_type" field.
func (m *ASTNodeMutation) ResetTreeSitterType() {
	m.tree_sitter_type = nil
	delete(m.clearedFields, astnode.FieldTreeSitterType)
}

// SetMetadata sets the "metadata" field.
func (m *ASTNodeMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ASTNodeMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ASTNodeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[astnode.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ASTNodeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[astnode.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ASTNodeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, astnode.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ASTNodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ASTNodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ASTNode entity.
// If the ASTNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASTNodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ASTNodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ASTNodeMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ASTNodeMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ASTNodeMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ASTNodeMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ASTNodeMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ASTNodeMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// AddChildIDs adds the "children" edge to the ASTNode entity by ids.
func (m *ASTNodeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ASTNode entity.
func (m *ASTNodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ASTNode entity was cleared.
func (m *ASTNodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ASTNode entity by IDs.
func (m *ASTNodeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ASTNode entity.
func (m *ASTNodeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ASTNodeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ASTNodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the ASTNode entity by id.
func (m *ASTNodeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ASTNode entity.
func (m *ASTNodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ASTNode entity was cleared.
func (m *ASTNodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ASTNodeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ASTNodeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ASTNodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetSymbolID sets the "symbol" edge to the Symbol entity by id.
func (m *ASTNodeMutation) SetSymbolID(id int) {
	m.symbol = &id
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *ASTNodeMutation) ClearSymbol() {
	m.clearedsymbol = true
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *ASTNodeMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolID returns the "symbol" edge ID in the mutation.
func (m *ASTNodeMutation) SymbolID() (id int, exists bool) {
	if m.symbol != nil {
		return *m.symbol, true
	}
	return
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *ASTNodeMutation) SymbolIDs() (ids []int) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *ASTNodeMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// AddReferenceIDs adds the "references" edge to the SymbolReference entity by ids.
func (m *ASTNodeMutation) AddReferenceIDs(ids ...int) {
	if m.references == nil {
		m.references = make(map[int]struct{})
	}
	for i := range ids {
		m.references[ids[i]] = struct{}{}
	}
}

// ClearReferences clears the "references" edge to the SymbolReference entity.
func (m *ASTNodeMutation) ClearReferences() {
	m.clearedreferences = true
}

// ReferencesCleared reports if the "references" edge to the SymbolReference entity was cleared.
func (m *ASTNodeMutation) ReferencesCleared() bool {
	return m.clearedreferences
}

// RemoveReferenceIDs removes the "references" edge to the SymbolReference entity by IDs.
func (m *ASTNodeMutation) RemoveReferenceIDs(ids ...int) {
	if m.removedreferences == nil {
		m.removedreferences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.references, ids[i])
		m.removedreferences[ids[i]] = struct{}{}
	}
}

// RemovedReferences returns the removed IDs of the "references" edge to the SymbolReference entity.
func (m *ASTNodeMutation) RemovedReferencesIDs() (ids []int) {
	for id := range m.removedreferences {
		ids = append(ids, id)
	}
	return
}

// ReferencesIDs returns the "references" edge IDs in the mutation.
func (m *ASTNodeMutation) ReferencesIDs() (ids []int) {
	for id := range m.references {
		ids = append(ids, id)
	}
	return
}

// ResetReferences resets all changes to the "references" edge.
func (m *ASTNodeMutation) ResetReferences() {
	m.references = nil
	m.clearedreferences = false
	m.removedreferences = nil
}

// Where appends a list predicates to the ASTNodeMutation builder.
func (m *ASTNodeMutation) Where(ps ...predicate.ASTNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ASTNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ASTNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ASTNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ASTNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ASTNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ASTNode).
func (m *ASTNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ASTNodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.node_type != nil {
		fields = append(fields, astnode.FieldNodeType)
	}
	if m.name != nil {
		fields = append(fields, astnode.FieldName)
	}
	if m.qualified_name != nil {
		fields = append(fields, astnode.FieldQualifiedName)
	}
	if m.start_line != nil {
		fields = append(fields, astnode.FieldStartLine)
	}
	if m.end_line != nil {
		fields = append(fields, astnode.FieldEndLine)
	}
	if m.start_column != nil {
		fields = append(fields, astnode.FieldStartColumn)
	}
	if m.end_column != nil {
		fields = append(fields, astnode.FieldEndColumn)
	}
	if m.content != nil {
		fields = append(fields, astnode.FieldContent)
	}
	if m.tree_sitter_type != nil {
		fields = append(fields, astnode.FieldTreeSitterType)
	}
	if m.metadata != nil {
		fields = append(fields, astnode.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, astnode.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ASTNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case astnode.FieldNodeType:
		return m.NodeType()
	case astnode.FieldName:
		return m.Name()
	case astnode.FieldQualifiedName:
		return m.QualifiedName()
	case astnode.FieldStartLine:
		return m.StartLine()
	case astnode.FieldEndLine:
		return m.EndLine()
	case astnode.FieldStartColumn:
		return m.StartColumn()
	case astnode.FieldEndColumn:
		return m.EndColumn()
	case astnode.FieldContent:
		return m.Content()
	case astnode.FieldTreeSitterType:
		return m.TreeSitterType()
	case astnode.FieldMetadata:
		return m.Metadata()
	case astnode.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ASTNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case astnode.FieldNodeType:
		return m.OldNodeType(ctx)
	case astnode.FieldName:
		return m.OldName(ctx)
	case astnode.FieldQualifiedName:
		return m.OldQualifiedName(ctx)
	case astnode.FieldStartLine:
		return m.OldStartLine(ctx)
	case astnode.FieldEndLine:
		return m.OldEndLine(ctx)
	case astnode.FieldStartColumn:
		return m.OldStartColumn(ctx)
	case astnode.FieldEndColumn:
		return m.OldEndColumn(ctx)
	case astnode.FieldContent:
		return m.OldContent(ctx)
	case astnode.FieldTreeSitterType:
		return m.OldTreeSitterType(ctx)
	case astnode.FieldMetadata:
		return m.OldMetadata(ctx)
	case astnode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ASTNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ASTNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case astnode.FieldNodeType:
		v, ok := value.(astnode.NodeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case astnode.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case astnode.FieldQualifiedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiedName(v)
		return nil
	case astnode.FieldStartLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartLine(v)
		return nil
	case astnode.FieldEndLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndLine(v)
		return nil
	case astnode.FieldStartColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartColumn(v)
		return nil
	case astnode.FieldEndColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndColumn(v)
		return nil
	case astnode.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case astnode.FieldTreeSitterType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreeSitterType(v)
		return nil
	case astnode.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case astnode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ASTNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ASTNodeMutation) AddedFields() []string {
	var fields []string
	if m.addstart_line != nil {
		fields = append(fields, astnode.FieldStartLine)
	}
	if m.addend_line != nil {
		fields = append(fields, astnode.FieldEndLine)
	}
	if m.addstart_column != nil {
		fields = append(fields, astnode.FieldStartColumn)
	}
	if m.addend_column != nil {
		fields = append(fields, astnode.FieldEndColumn)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ASTNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case astnode.FieldStartLine:
		return m.AddedStartLine()
	case astnode.FieldEndLine:
		return m.AddedEndLine()
	case astnode.FieldStartColumn:
		return m.AddedStartColumn()
	case astnode.FieldEndColumn:
		return m.AddedEndColumn()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ASTNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case astnode.FieldStartLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartLine(v)
		return nil
	case astnode.FieldEndLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndLine(v)
		return nil
	case astnode.FieldStartColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartColumn(v)
		return nil
	case astnode.FieldEndColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndColumn(v)
		return nil
	}
	return fmt.Errorf("unknown ASTNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ASTNodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(astnode.FieldName) {
		fields = append(fields, astnode.FieldName)
	}
	if m.FieldCleared(astnode.FieldQualifiedName) {
		fields = append(fields, astnode.FieldQualifiedName)
	}
	if m.FieldCleared(astnode.FieldContent) {
		fields = append(fields, astnode.FieldContent)
	}
	if m.FieldCleared(astnode.FieldTreeSitterType) {
		fields = append(fields, astnode.FieldTreeSitterType)
	}
	if m.FieldCleared(astnode.FieldMetadata) {
		fields = append(fields, astnode.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ASTNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ASTNodeMutation) ClearField(name string) error {
	switch name {
	case astnode.FieldName:
		m.ClearName()
		return nil
	case astnode.FieldQualifiedName:
		m.ClearQualifiedName()
		return nil
	case astnode.FieldContent:
		m.ClearContent()
		return nil
	case astnode.FieldTreeSitterType:
		m.ClearTreeSitterType()
		return nil
	case astnode.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ASTNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ASTNodeMutation) ResetField(name string) error {
	switch name {
	case astnode.FieldNodeType:
		m.ResetNodeType()
		return nil
	case astnode.FieldName:
		m.ResetName()
		return nil
	case astnode.FieldQualifiedName:
		m.ResetQualifiedName()
		return nil
	case astnode.FieldStartLine:
		m.ResetStartLine()
		return nil
	case astnode.FieldEndLine:
		m.ResetEndLine()
		return nil
	case astnode.FieldStartColumn:
		m.ResetStartColumn()
		return nil
	case astnode.FieldEndColumn:
		m.ResetEndColumn()
		return nil
	case astnode.FieldContent:
		m.ResetContent()
		return nil
	case astnode.FieldTreeSitterType:
		m.ResetTreeSitterType()
		return nil
	case astnode.FieldMetadata:
		m.ResetMetadata()
		return nil
	case astnode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ASTNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ASTNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.file != nil {
		edges = append(edges, astnode.EdgeFile)
	}
	if m.children != nil {
		edges = append(edges, astnode.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, astnode.EdgeParent)
	}
	if m.symbol != nil {
		edges = append(edges, astnode.EdgeSymbol)
	}
	if m.references != nil {
		edges = append(edges, astnode.EdgeReferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ASTNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case astnode.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case astnode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case astnode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case astnode.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case astnode.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.references))
		for id := range m.references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ASTNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, astnode.EdgeChildren)
	}
	if m.removedreferences != nil {
		edges = append(edges, astnode.EdgeReferences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ASTNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case astnode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case astnode.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.removedreferences))
		for id := range m.removedreferences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ASTNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedfile {
		edges = append(edges, astnode.EdgeFile)
	}
	if m.clearedchildren {
		edges = append(edges, astnode.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, astnode.EdgeParent)
	}
	if m.clearedsymbol {
		edges = append(edges, astnode.EdgeSymbol)
	}
	if m.clearedreferences {
		edges = append(edges, astnode.EdgeReferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ASTNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case astnode.EdgeFile:
		return m.clearedfile
	case astnode.EdgeChildren:
		return m.clearedchildren
	case astnode.EdgeParent:
		return m.clearedparent
	case astnode.EdgeSymbol:
		return m.clearedsymbol
	case astnode.EdgeReferences:
		return m.clearedreferences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ASTNodeMutation) ClearEdge(name string) error {
	switch name {
	case astnode.EdgeFile:
		m.ClearFile()
		return nil
	case astnode.EdgeParent:
		m.ClearParent()
		return nil
	case astnode.EdgeSymbol:
		m.ClearSymbol()
		return nil
	}
	return fmt.Errorf("unknown ASTNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ASTNodeMutation) ResetEdge(name string) error {
	switch name {
	case astnode.EdgeFile:
		m.ResetFile()
		return nil
	case astnode.EdgeChildren:
		m.ResetChildren()
		return nil
	case astnode.EdgeParent:
		m.ResetParent()
		return nil
	case astnode.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case astnode.EdgeReferences:
		m.ResetReferences()
		return nil
	}
	return fmt.Errorf("unknown ASTNode edge %s", name)
}

// CallRelationshipMutation represents an operation that mutates the CallRelationship nodes in the graph.
type CallRelationshipMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	call_site_line        *int
	addcall_site_line     *int
	call_site_column      *int
	addcall_site_column   *int
	call_type             *callrelationship.CallType
	is_conditional        *bool
	arguments             *[]string
	appendarguments       []string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	caller                *int
	clearedcaller         bool
	callee                *int
	clearedcallee         bool
	call_site_file        *int
	clearedcall_site_file bool
	done                  bool
	oldValue              func(context.Context) (*CallRelationship, error)
	predicates            []predicate.CallRelationship
}

var _ ent.Mutation = (*CallRelationshipMutation)(nil)

// callrelationshipOption allows management of the mutation configuration using functional options.
type callrelationshipOption func(*CallRelationshipMutation)

// newCallRelationshipMutation creates new mutation for the CallRelationship entity.
func newCallRelationshipMutation(c config, op Op, opts ...callrelationshipOption) *CallRelationshipMutation {
	m := &CallRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeCallRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCallRelationshipID sets the ID field of the mutation.
func withCallRelationshipID(id int) callrelationshipOption {
	return func(m *CallRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *CallRelationship
		)
		m.oldValue = func(ctx context.Context) (*CallRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CallRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCallRelationship sets the old CallRelationship of the mutation.
func withCallRelationship(node *CallRelationship) callrelationshipOption {
	return func(m *CallRelationshipMutation) {
		m.oldValue = func(context.Context) (*CallRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CallRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CallRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CallRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CallRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CallRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallSiteLine sets the "call_site_line" field.
func (m *CallRelationshipMutation) SetCallSiteLine(i int) {
	m.call_site_line = &i
	m.addcall_site_line = nil
}

// CallSiteLine returns the value of the "call_site_line" field in the mutation.
func (m *CallRelationshipMutation) CallSiteLine() (r int, exists bool) {
	v := m.call_site_line
	if v == nil {
		return
	}
	return *v, true
}

// OldCallSiteLine returns the old "call_site_line" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldCallSiteLine(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallSiteLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallSiteLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallSiteLine: %w", err)
	}
	return oldValue.CallSiteLine, nil
}

// AddCallSiteLine adds i to the "call_site_line" field.
func (m *CallRelationshipMutation) AddCallSiteLine(i int) {
	if m.addcall_site_line != nil {
		*m.addcall_site_line += i
	} else {
		m.addcall_site_line = &i
	}
}

// AddedCallSiteLine returns the value that was added to the "call_site_line" field in this mutation.
func (m *CallRelationshipMutation) AddedCallSiteLine() (r int, exists bool) {
	v := m.addcall_site_line
	if v == nil {
		return
	}
	return *v, true
}

// ResetCallSiteLine resets all changes to the "call_site_line" field.
func (m *CallRelationshipMutation) ResetCallSiteLine() {
	m.call_site_line = nil
	m.addcall_site_line = nil
}

// SetCallSiteColumn sets the "call_site_column" field.
func (m *CallRelationshipMutation) SetCallSiteColumn(i int) {
	m.call_site_column = &i
	m.addcall_site_column = nil
}

// CallSiteColumn returns the value of the "call_site_column" field in the mutation.
func (m *CallRelationshipMutation) CallSiteColumn() (r int, exists bool) {
	v := m.call_site_column
	if v == nil {
		return
	}
	return *v, true
}

// OldCallSiteColumn returns the old "call_site_column" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldCallSiteColumn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallSiteColumn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallSiteColumn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallSiteColumn: %w", err)
	}
	return oldValue.CallSiteColumn, nil
}

// AddCallSiteColumn adds i to the "call_site_column" field.
func (m *CallRelationshipMutation) AddCallSiteColumn(i int) {
	if m.addcall_site_column != nil {
		*m.addcall_site_column += i
	} else {
		m.addcall_site_column = &i
	}
}

// AddedCallSiteColumn returns the value that was added to the "call_site_column" field in this mutation.
func (m *CallRelationshipMutation) AddedCallSiteColumn() (r int, exists bool) {
	v := m.addcall_site_column
	if v == nil {
		return
	}
	return *v, true
}

// ResetCallSiteColumn resets all changes to the "call_site_column" field.
func (m *CallRelationshipMutation) ResetCallSiteColumn() {
	m.call_site_column = nil
	m.addcall_site_column = nil
}

// SetCallType sets the "call_type" field.
func (m *CallRelationshipMutation) SetCallType(ct callrelationship.CallType) {
	m.call_type = &ct
}

// CallType returns the value of the "call_type" field in the mutation.
func (m *CallRelationshipMutation) CallType() (r callrelationship.CallType, exists bool) {
	v := m.call_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCallType returns the old "call_type" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldCallType(ctx context.Context) (v callrelationship.CallType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallType: %w", err)
	}
	return oldValue.CallType, nil
}

// ResetCallType resets all changes to the "call_type" field.
func (m *CallRelationshipMutation) ResetCallType() {
	m.call_type = nil
}

// SetIsConditional sets the "is_conditional" field.
func (m *CallRelationshipMutation) SetIsConditional(b bool) {
	m.is_conditional = &b
}

// IsConditional returns the value of the "is_conditional" field in the mutation.
func (m *CallRelationshipMutation) IsConditional() (r bool, exists bool) {
	v := m.is_conditional
	if v == nil {
		return
	}
	return *v, true
}

// OldIsConditional returns the old "is_conditional" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldIsConditional(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsConditional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsConditional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsConditional: %w", err)
	}
	return oldValue.IsConditional, nil
}

// ResetIsConditional resets all changes to the "is_conditional" field.
func (m *CallRelationshipMutation) ResetIsConditional() {
	m.is_conditional = nil
}

// SetArguments sets the "arguments" field.
func (m *CallRelationshipMutation) SetArguments(s []string) {
	m.arguments = &s
	m.appendarguments = nil
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *CallRelationshipMutation) Arguments() (r []string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldArguments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// AppendArguments adds s to the "arguments" field.
func (m *CallRelationshipMutation) AppendArguments(s []string) {
	m.appendarguments = append(m.appendarguments, s...)
}

// AppendedArguments returns the list of values that were appended to the "arguments" field in this mutation.
func (m *CallRelationshipMutation) AppendedArguments() ([]string, bool) {
	if len(m.appendarguments) == 0 {
		return nil, false
	}
	return m.appendarguments, true
}

// ClearArguments clears the value of the "arguments" field.
func (m *CallRelationshipMutation) ClearArguments() {
	m.arguments = nil
	m.appendarguments = nil
	m.clearedFields[callrelationship.FieldArguments] = struct{}{}
}

// ArgumentsCleared returns if the "arguments" field was cleared in this mutation.
func (m *CallRelationshipMutation) ArgumentsCleared() bool {
	_, ok := m.clearedFields[callrelationship.FieldArguments]
	return ok
}

// ResetArguments resets all changes to the "arguments" field.
func (m *CallRelationshipMutation) ResetArguments() {
	m.arguments = nil
	m.appendarguments = nil
	delete(m.clearedFields, callrelationship.FieldArguments)
}

// SetCreatedAt sets the "created_at" field.
func (m *CallRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CallRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CallRelationship entity.
// If the CallRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CallRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCallerID sets the "caller" edge to the Symbol entity by id.
func (m *CallRelationshipMutation) SetCallerID(id int) {
	m.caller = &id
}

// ClearCaller clears the "caller" edge to the Symbol entity.
func (m *CallRelationshipMutation) ClearCaller() {
	m.clearedcaller = true
}

// CallerCleared reports if the "caller" edge to the Symbol entity was cleared.
func (m *CallRelationshipMutation) CallerCleared() bool {
	return m.clearedcaller
}

// CallerID returns the "caller" edge ID in the mutation.
func (m *CallRelationshipMutation) CallerID() (id int, exists bool) {
	if m.caller != nil {
		return *m.caller, true
	}
	return
}

// CallerIDs returns the "caller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallerID instead. It exists only for internal usage by the builders.
func (m *CallRelationshipMutation) CallerIDs() (ids []int) {
	if id := m.caller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaller resets all changes to the "caller" edge.
func (m *CallRelationshipMutation) ResetCaller() {
	m.caller = nil
	m.clearedcaller = false
}

// SetCalleeID sets the "callee" edge to the Symbol entity by id.
func (m *CallRelationshipMutation) SetCalleeID(id int) {
	m.callee = &id
}

// ClearCallee clears the "callee" edge to the Symbol entity.
func (m *CallRelationshipMutation) ClearCallee() {
	m.clearedcallee = true
}

// CalleeCleared reports if the "callee" edge to the Symbol entity was cleared.
func (m *CallRelationshipMutation) CalleeCleared() bool {
	return m.clearedcallee
}

// CalleeID returns the "callee" edge ID in the mutation.
func (m *CallRelationshipMutation) CalleeID() (id int, exists bool) {
	if m.callee != nil {
		return *m.callee, true
	}
	return
}

// CalleeIDs returns the "callee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CalleeID instead. It exists only for internal usage by the builders.
func (m *CallRelationshipMutation) CalleeIDs() (ids []int) {
	if id := m.callee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCallee resets all changes to the "callee" edge.
func (m *CallRelationshipMutation) ResetCallee() {
	m.callee = nil
	m.clearedcallee = false
}

// SetCallSiteFileID sets the "call_site_file" edge to the File entity by id.
func (m *CallRelationshipMutation) SetCallSiteFileID(id int) {
	m.call_site_file = &id
}

// ClearCallSiteFile clears the "call_site_file" edge to the File entity.
func (m *CallRelationshipMutation) ClearCallSiteFile() {
	m.clearedcall_site_file = true
}

// CallSiteFileCleared reports if the "call_site_file" edge to the File entity was cleared.
func (m *CallRelationshipMutation) CallSiteFileCleared() bool {
	return m.clearedcall_site_file
}

// CallSiteFileID returns the "call_site_file" edge ID in the mutation.
func (m *CallRelationshipMutation) CallSiteFileID() (id int, exists bool) {
	if m.call_site_file != nil {
		return *m.call_site_file, true
	}
	return
}

// CallSiteFileIDs returns the "call_site_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallSiteFileID instead. It exists only for internal usage by the builders.
func (m *CallRelationshipMutation) CallSiteFileIDs() (ids []int) {
	if id := m.call_site_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCallSiteFile resets all changes to the "call_site_file" edge.
func (m *CallRelationshipMutation) ResetCallSiteFile() {
	m.call_site_file = nil
	m.clearedcall_site_file = false
}

// Where appends a list predicates to the CallRelationshipMutation builder.
func (m *CallRelationshipMutation) Where(ps ...predicate.CallRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CallRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CallRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CallRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CallRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CallRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CallRelationship).
func (m *CallRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CallRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.call_site_line != nil {
		fields = append(fields, callrelationship.FieldCallSiteLine)
	}
	if m.call_site_column != nil {
		fields = append(fields, callrelationship.FieldCallSiteColumn)
	}
	if m.call_type != nil {
		fields = append(fields, callrelationship.FieldCallType)
	}
	if m.is_conditional != nil {
		fields = append(fields, callrelationship.FieldIsConditional)
	}
	if m.arguments != nil {
		fields = append(fields, callrelationship.FieldArguments)
	}
	if m.created_at != nil {
		fields = append(fields, callrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CallRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case callrelationship.FieldCallSiteLine:
		return m.CallSiteLine()
	case callrelationship.FieldCallSiteColumn:
		return m.CallSiteColumn()
	case callrelationship.FieldCallType:
		return m.CallType()
	case callrelationship.FieldIsConditional:
		return m.IsConditional()
	case callrelationship.FieldArguments:
		return m.Arguments()
	case callrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CallRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case callrelationship.FieldCallSiteLine:
		return m.OldCallSiteLine(ctx)
	case callrelationship.FieldCallSiteColumn:
		return m.OldCallSiteColumn(ctx)
	case callrelationship.FieldCallType:
		return m.OldCallType(ctx)
	case callrelationship.FieldIsConditional:
		return m.OldIsConditional(ctx)
	case callrelationship.FieldArguments:
		return m.OldArguments(ctx)
	case callrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CallRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case callrelationship.FieldCallSiteLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallSiteLine(v)
		return nil
	case callrelationship.FieldCallSiteColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallSiteColumn(v)
		return nil
	case callrelationship.FieldCallType:
		v, ok := value.(callrelationship.CallType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallType(v)
		return nil
	case callrelationship.FieldIsConditional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsConditional(v)
		return nil
	case callrelationship.FieldArguments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	case callrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CallRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CallRelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addcall_site_line != nil {
		fields = append(fields, callrelationship.FieldCallSiteLine)
	}
	if m.addcall_site_column != nil {
		fields = append(fields, callrelationship.FieldCallSiteColumn)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CallRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case callrelationship.FieldCallSiteLine:
		return m.AddedCallSiteLine()
	case callrelationship.FieldCallSiteColumn:
		return m.AddedCallSiteColumn()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case callrelationship.FieldCallSiteLine:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCallSiteLine(v)
		return nil
	case callrelationship.FieldCallSiteColumn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCallSiteColumn(v)
		return nil
	}
	return fmt.Errorf("unknown CallRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CallRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(callrelationship.FieldArguments) {
		fields = append(fields, callrelationship.FieldArguments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CallRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CallRelationshipMutation) ClearField(name string) error {
	switch name {
	case callrelationship.FieldArguments:
		m.ClearArguments()
		return nil
	}
	return fmt.Errorf("unknown CallRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CallRelationshipMutation) ResetField(name string) error {
	switch name {
	case callrelationship.FieldCallSiteLine:
		m.ResetCallSiteLine()
		return nil
	case callrelationship.FieldCallSiteColumn:
		m.ResetCallSiteColumn()
		return nil
	case callrelationship.FieldCallType:
		m.ResetCallType()
		return nil
	case callrelationship.FieldIsConditional:
		m.ResetIsConditional()
		return nil
	case callrelationship.FieldArguments:
		m.ResetArguments()
		return nil
	case callrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CallRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CallRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.caller != nil {
		edges = append(edges, callrelationship.EdgeCaller)
	}
	if m.callee != nil {
		edges = append(edges, callrelationship.EdgeCallee)
	}
	if m.call_site_file != nil {
		edges = append(edges, callrelationship.EdgeCallSiteFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CallRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case callrelationship.EdgeCaller:
		if id := m.caller; id != nil {
			return []ent.Value{*id}
		}
	case callrelationship.EdgeCallee:
		if id := m.callee; id != nil {
			return []ent.Value{*id}
		}
	case callrelationship.EdgeCallSiteFile:
		if id := m.call_site_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CallRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CallRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CallRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcaller {
		edges = append(edges, callrelationship.EdgeCaller)
	}
	if m.clearedcallee {
		edges = append(edges, callrelationship.EdgeCallee)
	}
	if m.clearedcall_site_file {
		edges = append(edges, callrelationship.EdgeCallSiteFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CallRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case callrelationship.EdgeCaller:
		return m.clearedcaller
	case callrelationship.EdgeCallee:
		return m.clearedcallee
	case callrelationship.EdgeCallSiteFile:
		return m.clearedcall_site_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CallRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case callrelationship.EdgeCaller:
		m.ClearCaller()
		return nil
	case callrelationship.EdgeCallee:
		m.ClearCallee()
		return nil
	case callrelationship.EdgeCallSiteFile:
		m.ClearCallSiteFile()
		return nil
	}
	return fmt.Errorf("unknown CallRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CallRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case callrelationship.EdgeCaller:
		m.ResetCaller()
		return nil
	case callrelationship.EdgeCallee:
		m.ResetCallee()
		return nil
	case callrelationship.EdgeCallSiteFile:
		m.ResetCallSiteFile()
		return nil
	}
	return fmt.Errorf("unknown CallRelationship edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	relative_path            *string
	absolute_path            *string
	language                 *file.Language
	content_hash             *string
	size_bytes               *int
	addsize_bytes            *int
	line_count               *int
	addline_count            *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	project                  *int
	clearedproject           bool
	ast_nodes                map[int]struct{}
	removedast_nodes         map[int]struct{}
	clearedast_nodes         bool
	symbols                  map[int]struct{}
	removedsymbols           map[int]struct{}
	clearedsymbols           bool
	imports                  map[int]struct{}
	removedimports           map[int]struct{}
	clearedimports           bool
	call_sites               map[int]struct{}
	removedcall_sites        map[int]struct{}
	clearedcall_sites        bool
	inheritance_sites        map[int]struct{}
	removedinheritance_sites map[int]struct{}
	clearedinheritance_sites bool
	symbol_references        map[int]struct{}
	removedsymbol_references map[int]struct{}
	clearedsymbol_references bool
	done                     bool
	oldValue                 func(context.Context) (*File, error)
	predicates               []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRelativePath sets the "relative_path" field.
func (m *FileMutation) SetRelativePath(s string) {
	m.relative_path = &s
}

// RelativePath returns the value of the "relative_path" field in the mutation.
func (m *FileMutation) RelativePath() (r string, exists bool) {
	v := m.relative_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRelativePath returns the old "relative_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldRelativePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelativePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelativePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelativePath: %w", err)
	}
	return oldValue.RelativePath, nil
}

// ResetRelativePath resets all changes to the "relative_path" field.
func (m *FileMutation) ResetRelativePath() {
	m.relative_path = nil
}

// SetAbsolutePath sets the "absolute_path" field.
func (m *FileMutation) SetAbsolutePath(s string) {
	m.absolute_path = &s
}

// AbsolutePath returns the value of the "absolute_path" field in the mutation.
func (m *FileMutation) AbsolutePath() (r string, exists bool) {
	v := m.absolute_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsolutePath returns the old "absolute_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldAbsolutePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsolutePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsolutePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsolutePath: %w", err)
	}
	return oldValue.AbsolutePath, nil
}

// ResetAbsolutePath resets all changes to the "absolute_path" field.
func (m *FileMutation) ResetAbsolutePath() {
	m.absolute_path = nil
}

// SetLanguage sets the "language" field.
func (m *FileMutation) SetLanguage(f file.Language) {
	m.language = &f
}

// Language returns the value of the "language" field in the mutation.
func (m *FileMutation) Language() (r file.Language, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldLanguage(ctx context.Context) (v file.Language, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *FileMutation) ResetLanguage() {
	m.language = nil
}

// SetContentHash sets the "content_hash" field.
func (m *FileMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *FileMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *FileMutation) ResetContentHash() {
	m.content_hash = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *FileMutation) SetSizeBytes(i int) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *FileMutation) SizeBytes() (r int, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSizeBytes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *FileMutation) AddSizeBytes(i int) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *FileMutation) AddedSizeBytes() (r int, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *FileMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetLineCount sets the "line_count" field.
func (m *FileMutation) SetLineCount(i int) {
	m.line_count = &i
	m.addline_count = nil
}

// LineCount returns the value of the "line_count" field in the mutation.
func (m *FileMutation) LineCount() (r int, exists bool) {
	v := m.line_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLineCount returns the old "line_count" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldLineCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineCount: %w", err)
	}
	return oldValue.LineCount, nil
}

// AddLineCount adds i to the "line_count" field.
func (m *FileMutation) AddLineCount(i int) {
	if m.addline_count != nil {
		*m.addline_count += i
	} else {
		m.addline_count = &i
	}
}

// AddedLineCount returns the value that was added to the "line_count" field in this mutation.
func (m *FileMutation) AddedLineCount() (r int, exists bool) {
	v := m.addline_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineCount resets all changes to the "line_count" field.
func (m *FileMutation) ResetLineCount() {
	m.line_count = nil
	m.addline_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *FileMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *FileMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *FileMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *FileMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *FileMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddAstNodeIDs adds the "ast_nodes" edge to the ASTNode entity by ids.
func (m *FileMutation) AddAstNodeIDs(ids ...int) {
	if m.ast_nodes == nil {
		m.ast_nodes = make(map[int]struct{})
	}
	for i := range ids {
		m.ast_nodes[ids[i]] = struct{}{}
	}
}

// ClearAstNodes clears the "ast_nodes" edge to the ASTNode entity.
func (m *FileMutation) ClearAstNodes() {
	m.clearedast_nodes = true
}

// AstNodesCleared reports if the "ast_nodes" edge to the ASTNode entity was cleared.
func (m *FileMutation) AstNodesCleared() bool {
	return m.clearedast_nodes
}

// RemoveAstNodeIDs removes the "ast_nodes" edge to the ASTNode entity by IDs.
func (m *FileMutation) RemoveAstNodeIDs(ids ...int) {
	if m.removedast_nodes == nil {
		m.removedast_nodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ast_nodes, ids[i])
		m.removedast_nodes[ids[i]] = struct{}{}
	}
}

// RemovedAstNodes returns the removed IDs of the "ast_nodes" edge to the ASTNode entity.
func (m *FileMutation) RemovedAstNodesIDs() (ids []int) {
	for id := range m.removedast_nodes {
		ids = append(ids, id)
	}
	return
}

// AstNodesIDs returns the "ast_nodes" edge IDs in the mutation.
func (m *FileMutation) AstNodesIDs() (ids []int) {
	for id := range m.ast_nodes {
		ids = append(ids, id)
	}
	return
}

// ResetAstNodes resets all changes to the "ast_nodes" edge.
func (m *FileMutation) ResetAstNodes() {
	m.ast_nodes = nil
	m.clearedast_nodes = false
	m.removedast_nodes = nil
}

// AddSymbolIDs adds the "symbols" edge to the Symbol entity by ids.
func (m *FileMutation) AddSymbolIDs(ids ...int) {
	if m.symbols == nil {
		m.symbols = make(map[int]struct{})
	}
	for i := range ids {
		m.symbols[ids[i]] = struct{}{}
	}
}

// ClearSymbols clears the "symbols" edge to the Symbol entity.
func (m *FileMutation) ClearSymbols() {
	m.clearedsymbols = true
}

// SymbolsCleared reports if the "symbols" edge to the Symbol entity was cleared.
func (m *FileMutation) SymbolsCleared() bool {
	return m.clearedsymbols
}

// RemoveSymbolIDs removes the "symbols" edge to the Symbol entity by IDs.
func (m *FileMutation) RemoveSymbolIDs(ids ...int) {
	if m.removedsymbols == nil {
		m.removedsymbols = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.symbols, ids[i])
		m.removedsymbols[ids[i]] = struct{}{}
	}
}

// RemovedSymbols returns the removed IDs of the "symbols" edge to the Symbol entity.
func (m *FileMutation) RemovedSymbolsIDs() (ids []int) {
	for id := range m.removedsymbols {
		ids = append(ids, id)
	}
	return
}

// SymbolsIDs returns the "symbols" edge IDs in the mutation.
func (m *FileMutation) SymbolsIDs() (ids []int) {
	for id := range m.symbols {
		ids = append(ids, id)
	}
	return
}

// ResetSymbols resets all changes to the "symbols" edge.
func (m *FileMutation) ResetSymbols() {
	m.symbols = nil
	m.clearedsymbols = false
	m.removedsymbols = nil
}

// AddImportIDs adds the "imports" edge to the ImportStatement entity by ids.
func (m *FileMutation) AddImportIDs(ids ...int) {
	if m.imports == nil {
		m.imports = make(map[int]struct{})
	}
	for i := range ids {
		m.imports[ids[i]] = struct{}{}
	}
}

// ClearImports clears the "imports" edge to the ImportStatement entity.
func (m *FileMutation) ClearImports() {
	m.clearedimports = true
}

// ImportsCleared reports if the "imports" edge to the ImportStatement entity was cleared.
func (m *FileMutation) ImportsCleared() bool {
	return m.clearedimports
}

// RemoveImportIDs removes the "imports" edge to the ImportStatement entity by IDs.
func (m *FileMutation) RemoveImportIDs(ids ...int) {
	if m.removedimports == nil {
		m.removedimports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.imports, ids[i])
		m.removedimports[ids[i]] = struct{}{}
	}
}

// RemovedImports returns the removed IDs of the "imports" edge to the ImportStatement entity.
func (m *FileMutation) RemovedImportsIDs() (ids []int) {
	for id := range m.removedimports {
		ids = append(ids, id)
	}
	return
}

// ImportsIDs returns the "imports" edge IDs in the mutation.
func (m *FileMutation) ImportsIDs() (ids []int) {
	for id := range m.imports {
		ids = append(ids, id)
	}
	return
}

// ResetImports resets all changes to the "imports" edge.
func (m *FileMutation) ResetImports() {
	m.imports = nil
	m.clearedimports = false
	m.removedimports = nil
}

// AddCallSiteIDs adds the "call_sites" edge to the CallRelationship entity by ids.
func (m *FileMutation) AddCallSiteIDs(ids ...int) {
	if m.call_sites == nil {
		m.call_sites = make(map[int]struct{})
	}
	for i := range ids {
		m.call_sites[ids[i]] = struct{}{}
	}
}

// ClearCallSites clears the "call_sites" edge to the CallRelationship entity.
func (m *FileMutation) ClearCallSites() {
	m.clearedcall_sites = true
}

// CallSitesCleared reports if the "call_sites" edge to the CallRelationship entity was cleared.
func (m *FileMutation) CallSitesCleared() bool {
	return m.clearedcall_sites
}

// RemoveCallSiteIDs removes the "call_sites" edge to the CallRelationship entity by IDs.
func (m *FileMutation) RemoveCallSiteIDs(ids ...int) {
	if m.removedcall_sites == nil {
		m.removedcall_sites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.call_sites, ids[i])
		m.removedcall_sites[ids[i]] = struct{}{}
	}
}

// RemovedCallSites returns the removed IDs of the "call_sites" edge to the CallRelationship entity.
func (m *FileMutation) RemovedCallSitesIDs() (ids []int) {
	for id := range m.removedcall_sites {
		ids = append(ids, id)
	}
	return
}

// CallSitesIDs returns the "call_sites" edge IDs in the mutation.
func (m *FileMutation) CallSitesIDs() (ids []int) {
	for id := range m.call_sites {
		ids = append(ids, id)
	}
	return
}

// ResetCallSites resets all changes to the "call_sites" edge.
func (m *FileMutation) ResetCallSites() {
	m.call_sites = nil
	m.clearedcall_sites = false
	m.removedcall_sites = nil
}

// AddInheritanceSiteIDs adds the "inheritance_sites" edge to the InheritanceRelationship entity by ids.
func (m *FileMutation) AddInheritanceSiteIDs(ids ...int) {
	if m.inheritance_sites == nil {
		m.inheritance_sites = make(map[int]struct{})
	}
	for i := range ids {
		m.inheritance_sites[ids[i]] = struct{}{}
	}
}

// ClearInheritanceSites clears the "inheritance_sites" edge to the InheritanceRelationship entity.
func (m *FileMutation) ClearInheritanceSites() {
	m.clearedinheritance_sites = true
}

// InheritanceSitesCleared reports if the "inheritance_sites" edge to the InheritanceRelationship entity was cleared.
func (m *FileMutation) InheritanceSitesCleared() bool {
	return m.clearedinheritance_sites
}

// RemoveInheritanceSiteIDs removes the "inheritance_sites" edge to the InheritanceRelationship entity by IDs.
func (m *FileMutation) RemoveInheritanceSiteIDs(ids ...int) {
	if m.removedinheritance_sites == nil {
		m.removedinheritance_sites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inheritance_sites, ids[i])
		m.removedinheritance_sites[ids[i]] = struct{}{}
	}
}

// RemovedInheritanceSites returns the removed IDs of the "inheritance_sites" edge to the InheritanceRelationship entity.
func (m *FileMutation) RemovedInheritanceSitesIDs() (ids []int) {
	for id := range m.removedinheritance_sites {
		ids = append(ids, id)
	}
	return
}

// InheritanceSitesIDs returns the "inheritance_sites" edge IDs in the mutation.
func (m *FileMutation) InheritanceSitesIDs() (ids []int) {
	for id := range m.inheritance_sites {
		ids = append(ids, id)
	}
	return
}

// ResetInheritanceSites resets all changes to the "inheritance_sites" edge.
func (m *FileMutation) ResetInheritanceSites() {
	m.inheritance_sites = nil
	m.clearedinheritance_sites = false
	m.removedinheritance_sites = nil
}

// AddSymbolReferenceIDs adds the "symbol_references" edge to the SymbolReference entity by ids.
func (m *FileMutation) AddSymbolReferenceIDs(ids ...int) {
	if m.symbol_references == nil {
		m.symbol_references = make(map[int]struct{})
	}
	for i := range ids {
		m.symbol_references[ids[i]] = struct{}{}
	}
}

// ClearSymbolReferences clears the "symbol_references" edge to the SymbolReference entity.
func (m *FileMutation) ClearSymbolReferences() {
	m.clearedsymbol_references = true
}

// SymbolReferencesCleared reports if the "symbol_references" edge to the SymbolReference entity was cleared.
func (m *FileMutation) SymbolReferencesCleared() bool {
	return m.clearedsymbol_references
}

// RemoveSymbolReferenceIDs removes the "symbol_references" edge to the SymbolReference entity by IDs.
func (m *FileMutation) RemoveSymbolReferenceIDs(ids ...int) {
	if m.removedsymbol_references == nil {
		m.removedsymbol_references = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.symbol_references, ids[i])
		m.removedsymbol_references[ids[i]] = struct{}{}
	}
}

// RemovedSymbolReferences returns the removed IDs of the "symbol_references" edge to the SymbolReference entity.
func (m *FileMutation) RemovedSymbolReferencesIDs() (ids []int) {
	for id := range m.removedsymbol_references {
		ids = append(ids, id)
	}
	return
}

// SymbolReferencesIDs returns the "symbol_references" edge IDs in the mutation.
func (m *FileMutation) SymbolReferencesIDs() (ids []int) {
	for id := range m.symbol_references {
		ids = append(ids, id)
	}
	return
}

// ResetSymbolReferences resets all changes to the "symbol_references" edge.
func (m *FileMutation) ResetSymbolReferences() {
	m.symbol_references = nil
	m.clearedsymbol_references = false
	m.removedsymbol_references = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.relative_path != nil {
		fields = append(fields, file.FieldRelativePath)
	}
	if m.absolute_path != nil {
		fields = append(fields, file.FieldAbsolutePath)
	}
	if m.language != nil {
		fields = append(fields, file.FieldLanguage)
	}
	if m.content_hash != nil {
		fields = append(fields, file.FieldContentHash)
	}
	if m.size_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	if m.line_count != nil {
		fields = append(fields, file.FieldLineCount)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldRelativePath:
		return m.RelativePath()
	case file.FieldAbsolutePath:
		return m.AbsolutePath()
	case file.FieldLanguage:
		return m.Language()
	case file.FieldContentHash:
		return m.ContentHash()
	case file.FieldSizeBytes:
		return m.SizeBytes()
	case file.FieldLineCount:
		return m.LineCount()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldRelativePath:
		return m.OldRelativePath(ctx)
	case file.FieldAbsolutePath:
		return m.OldAbsolutePath(ctx)
	case file.FieldLanguage:
		return m.OldLanguage(ctx)
	case file.FieldContentHash:
		return m.OldContentHash(ctx)
	case file.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case file.FieldLineCount:
		return m.OldLineCount(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldRelativePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelativePath(v)
		return nil
	case file.FieldAbsolutePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsolutePath(v)
		return nil
	case file.FieldLanguage:
		v, ok := value.(file.Language)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case file.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	case file.FieldSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case file.FieldLineCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineCount(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, file.FieldSizeBytes)
	}
	if m.addline_count != nil {
		fields = append(fields, file.FieldLineCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSizeBytes:
		return m.AddedSizeBytes()
	case file.FieldLineCount:
		return m.AddedLineCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	case file.FieldLineCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineCount(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldRelativePath:
		m.ResetRelativePath()
		return nil
	case file.FieldAbsolutePath:
		m.ResetAbsolutePath()
		return nil
	case file.FieldLanguage:
		m.ResetLanguage()
		return nil
	case file.FieldContentHash:
		m.ResetContentHash()
		return nil
	case file.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case file.FieldLineCount:
		m.ResetLineCount()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.project != nil {
		edges = append(edges, file.EdgeProject)
	}
	if m.ast_nodes != nil {
		edges = append(edges, file.EdgeAstNodes)
	}
	if m.symbols != nil {
		edges = append(edges, file.EdgeSymbols)
	}
	if m.imports != nil {
		edges = append(edges, file.EdgeImports)
	}
	if m.call_sites != nil {
		edges = append(edges, file.EdgeCallSites)
	}
	if m.inheritance_sites != nil {
		edges = append(edges, file.EdgeInheritanceSites)
	}
	if m.symbol_references != nil {
		edges = append(edges, file.EdgeSymbolReferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeAstNodes:
		ids := make([]ent.Value, 0, len(m.ast_nodes))
		for id := range m.ast_nodes {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeSymbols:
		ids := make([]ent.Value, 0, len(m.symbols))
		for id := range m.symbols {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImports:
		ids := make([]ent.Value, 0, len(m.imports))
		for id := range m.imports {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeCallSites:
		ids := make([]ent.Value, 0, len(m.call_sites))
		for id := range m.call_sites {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeInheritanceSites:
		ids := make([]ent.Value, 0, len(m.inheritance_sites))
		for id := range m.inheritance_sites {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeSymbolReferences:
		ids := make([]ent.Value, 0, len(m.symbol_references))
		for id := range m.symbol_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedast_nodes != nil {
		edges = append(edges, file.EdgeAstNodes)
	}
	if m.removedsymbols != nil {
		edges = append(edges, file.EdgeSymbols)
	}
	if m.removedimports != nil {
		edges = append(edges, file.EdgeImports)
	}
	if m.removedcall_sites != nil {
		edges = append(edges, file.EdgeCallSites)
	}
	if m.removedinheritance_sites != nil {
		edges = append(edges, file.EdgeInheritanceSites)
	}
	if m.removedsymbol_references != nil {
		edges = append(edges, file.EdgeSymbolReferences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeAstNodes:
		ids := make([]ent.Value, 0, len(m.removedast_nodes))
		for id := range m.removedast_nodes {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeSymbols:
		ids := make([]ent.Value, 0, len(m.removedsymbols))
		for id := range m.removedsymbols {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeImports:
		ids := make([]ent.Value, 0, len(m.removedimports))
		for id := range m.removedimports {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeCallSites:
		ids := make([]ent.Value, 0, len(m.removedcall_sites))
		for id := range m.removedcall_sites {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeInheritanceSites:
		ids := make([]ent.Value, 0, len(m.removedinheritance_sites))
		for id := range m.removedinheritance_sites {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeSymbolReferences:
		ids := make([]ent.Value, 0, len(m.removedsymbol_references))
		for id := range m.removedsymbol_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedproject {
		edges = append(edges, file.EdgeProject)
	}
	if m.clearedast_nodes {
		edges = append(edges, file.EdgeAstNodes)
	}
	if m.clearedsymbols {
		edges = append(edges, file.EdgeSymbols)
	}
	if m.clearedimports {
		edges = append(edges, file.EdgeImports)
	}
	if m.clearedcall_sites {
		edges = append(edges, file.EdgeCallSites)
	}
	if m.clearedinheritance_sites {
		edges = append(edges, file.EdgeInheritanceSites)
	}
	if m.clearedsymbol_references {
		edges = append(edges, file.EdgeSymbolReferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeProject:
		return m.clearedproject
	case file.EdgeAstNodes:
		return m.clearedast_nodes
	case file.EdgeSymbols:
		return m.clearedsymbols
	case file.EdgeImports:
		return m.clearedimports
	case file.EdgeCallSites:
		return m.clearedcall_sites
	case file.EdgeInheritanceSites:
		return m.clearedinheritance_sites
	case file.EdgeSymbolReferences:
		return m.clearedsymbol_references
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeProject:
		m.ResetProject()
		return nil
	case file.EdgeAstNodes:
		m.ResetAstNodes()
		return nil
	case file.EdgeSymbols:
		m.ResetSymbols()
		return nil
	case file.EdgeImports:
		m.ResetImports()
		return nil
	case file.EdgeCallSites:
		m.ResetCallSites()
		return nil
	case file.EdgeInheritanceSites:
		m.ResetInheritanceSites()
		return nil
	case file.EdgeSymbolReferences:
		m.ResetSymbolReferences()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// ImportStatementMutation represents an operation that mutates the ImportStatement nodes in the graph.
type ImportStatementMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	module_name            *string
	import_alias           *string
	import_type            *importstatement.ImportType
	line_number            *int
	addline_number         *int
	is_dynamic             *bool
	imported_names         *[]string
	appendimported_names   []string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	file                   *int
	clearedfile            bool
	imported_symbol        *int
	clearedimported_symbol bool
	done                   bool
	oldValue               func(context.Context) (*ImportStatement, error)
	predicates             []predicate.ImportStatement
}

var _ ent.Mutation = (*ImportStatementMutation)(nil)

// importstatementOption allows management of the mutation configuration using functional options.
type importstatementOption func(*ImportStatementMutation)

// newImportStatementMutation creates new mutation for the ImportStatement entity.
func newImportStatementMutation(c config, op Op, opts ...importstatementOption) *ImportStatementMutation {
	m := &ImportStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeImportStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImportStatementID sets the ID field of the mutation.
func withImportStatementID(id int) importstatementOption {
	return func(m *ImportStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *ImportStatement
		)
		m.oldValue = func(ctx context.Context) (*ImportStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImportStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImportStatement sets the old ImportStatement of the mutation.
func withImportStatement(node *ImportStatement) importstatementOption {
	return func(m *ImportStatementMutation) {
		m.oldValue = func(context.Context) (*ImportStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImportStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImportStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImportStatementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImportStatementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImportStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModuleName sets the "module_name" field.
func (m *ImportStatementMutation) SetModuleName(s string) {
	m.module_name = &s
}

// ModuleName returns the value of the "module_name" field in the mutation.
func (m *ImportStatementMutation) ModuleName() (r string, exists bool) {
	v := m.module_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleName returns the old "module_name" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldModuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleName: %w", err)
	}
	return oldValue.ModuleName, nil
}

// ResetModuleName resets all changes to the "module_name" field.
func (m *ImportStatementMutation) ResetModuleName() {
	m.module_name = nil
}

// SetImportAlias sets the "import_alias" field.
func (m *ImportStatementMutation) SetImportAlias(s string) {
	m.import_alias = &s
}

// ImportAlias returns the value of the "import_alias" field in the mutation.
func (m *ImportStatementMutation) ImportAlias() (r string, exists bool) {
	v := m.import_alias
	if v == nil {
		return
	}
	return *v, true
}

// OldImportAlias returns the old "import_alias" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldImportAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportAlias: %w", err)
	}
	return oldValue.ImportAlias, nil
}

// ClearImportAlias clears the value of the "import_alias" field.
func (m *ImportStatementMutation) ClearImportAlias() {
	m.import_alias = nil
	m.clearedFields[importstatement.FieldImportAlias] = struct{}{}
}

// ImportAliasCleared returns if the "import_alias" field was cleared in this mutation.
func (m *ImportStatementMutation) ImportAliasCleared() bool {
	_, ok := m.clearedFields[importstatement.FieldImportAlias]
	return ok
}

// ResetImportAlias resets all changes to the "import_alias" field.
func (m *ImportStatementMutation) ResetImportAlias() {
	m.import_alias = nil
	delete(m.clearedFields, importstatement.FieldImportAlias)
}

// SetImportType sets the "import_type" field.
func (m *ImportStatementMutation) SetImportType(it importstatement.ImportType) {
	m.import_type = &it
}

// ImportType returns the value of the "import_type" field in the mutation.
func (m *ImportStatementMutation) ImportType() (r importstatement.ImportType, exists bool) {
	v := m.import_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImportType returns the old "import_type" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldImportType(ctx context.Context) (v importstatement.ImportType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportType: %w", err)
	}
	return oldValue.ImportType, nil
}

// ResetImportType resets all changes to the "import_type" field.
func (m *ImportStatementMutation) ResetImportType() {
	m.import_type = nil
}

// SetLineNumber sets the "line_number" field.
func (m *ImportStatementMutation) SetLineNumber(i int) {
	m.line_number = &i
	m.addline_number = nil
}

// LineNumber returns the value of the "line_number" field in the mutation.
func (m *ImportStatementMutation) LineNumber() (r int, exists bool) {
	v := m.line_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNumber returns the old "line_number" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldLineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNumber: %w", err)
	}
	return oldValue.LineNumber, nil
}

// AddLineNumber adds i to the "line_number" field.
func (m *ImportStatementMutation) AddLineNumber(i int) {
	if m.addline_number != nil {
		*m.addline_number += i
	} else {
		m.addline_number = &i
	}
}

// AddedLineNumber returns the value that was added to the "line_number" field in this mutation.
func (m *ImportStatementMutation) AddedLineNumber() (r int, exists bool) {
	v := m.addline_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNumber resets all changes to the "line_number" field.
func (m *ImportStatementMutation) ResetLineNumber() {
	m.line_number = nil
	m.addline_number = nil
}

// SetIsDynamic sets the "is_dynamic" field.
func (m *ImportStatementMutation) SetIsDynamic(b bool) {
	m.is_dynamic = &b
}

// IsDynamic returns the value of the "is_dynamic" field in the mutation.
func (m *ImportStatementMutation) IsDynamic() (r bool, exists bool) {
	v := m.is_dynamic
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDynamic returns the old "is_dynamic" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldIsDynamic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDynamic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDynamic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDynamic: %w", err)
	}
	return oldValue.IsDynamic, nil
}

// ResetIsDynamic resets all changes to the "is_dynamic" field.
func (m *ImportStatementMutation) ResetIsDynamic() {
	m.is_dynamic = nil
}

// SetImportedNames sets the "imported_names" field.
func (m *ImportStatementMutation) SetImportedNames(s []string) {
	m.imported_names = &s
	m.appendimported_names = nil
}

// ImportedNames returns the value of the "imported_names" field in the mutation.
func (m *ImportStatementMutation) ImportedNames() (r []string, exists bool) {
	v := m.imported_names
	if v == nil {
		return
	}
	return *v, true
}

// OldImportedNames returns the old "imported_names" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldImportedNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportedNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportedNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportedNames: %w", err)
	}
	return oldValue.ImportedNames, nil
}

// AppendImportedNames adds s to the "imported_names" field.
func (m *ImportStatementMutation) AppendImportedNames(s []string) {
	m.appendimported_names = append(m.appendimported_names, s...)
}

// AppendedImportedNames returns the list of values that were appended to the "imported_names" field in this mutation.
func (m *ImportStatementMutation) AppendedImportedNames() ([]string, bool) {
	if len(m.appendimported_names) == 0 {
		return nil, false
	}
	return m.appendimported_names, true
}

// ClearImportedNames clears the value of the "imported_names" field.
func (m *ImportStatementMutation) ClearImportedNames() {
	m.imported_names = nil
	m.appendimported_names = nil
	m.clearedFields[importstatement.FieldImportedNames] = struct{}{}
}

// ImportedNamesCleared returns if the "imported_names" field was cleared in this mutation.
func (m *ImportStatementMutation) ImportedNamesCleared() bool {
	_, ok := m.clearedFields[importstatement.FieldImportedNames]
	return ok
}

// ResetImportedNames resets all changes to the "imported_names" field.
func (m *ImportStatementMutation) ResetImportedNames() {
	m.imported_names = nil
	m.appendimported_names = nil
	delete(m.clearedFields, importstatement.FieldImportedNames)
}

// SetCreatedAt sets the "created_at" field.
func (m *ImportStatementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImportStatementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImportStatement entity.
// If the ImportStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportStatementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImportStatementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ImportStatementMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ImportStatementMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ImportStatementMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ImportStatementMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ImportStatementMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ImportStatementMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetImportedSymbolID sets the "imported_symbol" edge to the Symbol entity by id.
func (m *ImportStatementMutation) SetImportedSymbolID(id int) {
	m.imported_symbol = &id
}

// ClearImportedSymbol clears the "imported_symbol" edge to the Symbol entity.
func (m *ImportStatementMutation) ClearImportedSymbol() {
	m.clearedimported_symbol = true
}

// ImportedSymbolCleared reports if the "imported_symbol" edge to the Symbol entity was cleared.
func (m *ImportStatementMutation) ImportedSymbolCleared() bool {
	return m.clearedimported_symbol
}

// ImportedSymbolID returns the "imported_symbol" edge ID in the mutation.
func (m *ImportStatementMutation) ImportedSymbolID() (id int, exists bool) {
	if m.imported_symbol != nil {
		return *m.imported_symbol, true
	}
	return
}

// ImportedSymbolIDs returns the "imported_symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImportedSymbolID instead. It exists only for internal usage by the builders.
func (m *ImportStatementMutation) ImportedSymbolIDs() (ids []int) {
	if id := m.imported_symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImportedSymbol resets all changes to the "imported_symbol" edge.
func (m *ImportStatementMutation) ResetImportedSymbol() {
	m.imported_symbol = nil
	m.clearedimported_symbol = false
}

// Where appends a list predicates to the ImportStatementMutation builder.
func (m *ImportStatementMutation) Where(ps ...predicate.ImportStatement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImportStatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImportStatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImportStatement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImportStatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImportStatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImportStatement).
func (m *ImportStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImportStatementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.module_name != nil {
		fields = append(fields, importstatement.FieldModuleName)
	}
	if m.import_alias != nil {
		fields = append(fields, importstatement.FieldImportAlias)
	}
	if m.import_type != nil {
		fields = append(fields, importstatement.FieldImportType)
	}
	if m.line_number != nil {
		fields = append(fields, importstatement.FieldLineNumber)
	}
	if m.is_dynamic != nil {
		fields = append(fields, importstatement.FieldIsDynamic)
	}
	if m.imported_names != nil {
		fields = append(fields, importstatement.FieldImportedNames)
	}
	if m.created_at != nil {
		fields = append(fields, importstatement.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImportStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case importstatement.FieldModuleName:
		return m.ModuleName()
	case importstatement.FieldImportAlias:
		return m.ImportAlias()
	case importstatement.FieldImportType:
		return m.ImportType()
	case importstatement.FieldLineNumber:
		return m.LineNumber()
	case importstatement.FieldIsDynamic:
		return m.IsDynamic()
	case importstatement.FieldImportedNames:
		return m.ImportedNames()
	case importstatement.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImportStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case importstatement.FieldModuleName:
		return m.OldModuleName(ctx)
	case importstatement.FieldImportAlias:
		return m.OldImportAlias(ctx)
	case importstatement.FieldImportType:
		return m.OldImportType(ctx)
	case importstatement.FieldLineNumber:
		return m.OldLineNumber(ctx)
	case importstatement.FieldIsDynamic:
		return m.OldIsDynamic(ctx)
	case importstatement.FieldImportedNames:
		return m.OldImportedNames(ctx)
	case importstatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ImportStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case importstatement.FieldModuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleName(v)
		return nil
	case importstatement.FieldImportAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportAlias(v)
		return nil
	case importstatement.FieldImportType:
		v, ok := value.(importstatement.ImportType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportType(v)
		return nil
	case importstatement.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNumber(v)
		return nil
	case importstatement.FieldIsDynamic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDynamic(v)
		return nil
	case importstatement.FieldImportedNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportedNames(v)
		return nil
	case importstatement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ImportStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImportStatementMutation) AddedFields() []string {
	var fields []string
	if m.addline_number != nil {
		fields = append(fields, importstatement.FieldLineNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImportStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case importstatement.FieldLineNumber:
		return m.AddedLineNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case importstatement.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ImportStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImportStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(importstatement.FieldImportAlias) {
		fields = append(fields, importstatement.FieldImportAlias)
	}
	if m.FieldCleared(importstatement.FieldImportedNames) {
		fields = append(fields, importstatement.FieldImportedNames)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImportStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImportStatementMutation) ClearField(name string) error {
	switch name {
	case importstatement.FieldImportAlias:
		m.ClearImportAlias()
		return nil
	case importstatement.FieldImportedNames:
		m.ClearImportedNames()
		return nil
	}
	return fmt.Errorf("unknown ImportStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImportStatementMutation) ResetField(name string) error {
	switch name {
	case importstatement.FieldModuleName:
		m.ResetModuleName()
		return nil
	case importstatement.FieldImportAlias:
		m.ResetImportAlias()
		return nil
	case importstatement.FieldImportType:
		m.ResetImportType()
		return nil
	case importstatement.FieldLineNumber:
		m.ResetLineNumber()
		return nil
	case importstatement.FieldIsDynamic:
		m.ResetIsDynamic()
		return nil
	case importstatement.FieldImportedNames:
		m.ResetImportedNames()
		return nil
	case importstatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ImportStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImportStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.file != nil {
		edges = append(edges, importstatement.EdgeFile)
	}
	if m.imported_symbol != nil {
		edges = append(edges, importstatement.EdgeImportedSymbol)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImportStatementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case importstatement.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case importstatement.EdgeImportedSymbol:
		if id := m.imported_symbol; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImportStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImportStatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImportStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfile {
		edges = append(edges, importstatement.EdgeFile)
	}
	if m.clearedimported_symbol {
		edges = append(edges, importstatement.EdgeImportedSymbol)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImportStatementMutation) EdgeCleared(name string) bool {
	switch name {
	case importstatement.EdgeFile:
		return m.clearedfile
	case importstatement.EdgeImportedSymbol:
		return m.clearedimported_symbol
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImportStatementMutation) ClearEdge(name string) error {
	switch name {
	case importstatement.EdgeFile:
		m.ClearFile()
		return nil
	case importstatement.EdgeImportedSymbol:
		m.ClearImportedSymbol()
		return nil
	}
	return fmt.Errorf("unknown ImportStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImportStatementMutation) ResetEdge(name string) error {
	switch name {
	case importstatement.EdgeFile:
		m.ResetFile()
		return nil
	case importstatement.EdgeImportedSymbol:
		m.ResetImportedSymbol()
		return nil
	}
	return fmt.Errorf("unknown ImportStatement edge %s", name)
}

// InheritanceRelationshipMutation represents an operation that mutates the InheritanceRelationship nodes in the graph.
type InheritanceRelationshipMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	relationship_type     *inheritancerelationship.RelationshipType
	line_number           *int
	addline_number        *int
	is_direct_inheritance *bool
	inheritance_depth     *int
	addinheritance_depth  *int
	module_name           *string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	child                 *int
	clearedchild          bool
	parent                *int
	clearedparent         bool
	file                  *int
	clearedfile           bool
	done                  bool
	oldValue              func(context.Context) (*InheritanceRelationship, error)
	predicates            []predicate.InheritanceRelationship
}

var _ ent.Mutation = (*InheritanceRelationshipMutation)(nil)

// inheritancerelationshipOption allows management of the mutation configuration using functional options.
type inheritancerelationshipOption func(*InheritanceRelationshipMutation)

// newInheritanceRelationshipMutation creates new mutation for the InheritanceRelationship entity.
func newInheritanceRelationshipMutation(c config, op Op, opts ...inheritancerelationshipOption) *InheritanceRelationshipMutation {
	m := &InheritanceRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeInheritanceRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInheritanceRelationshipID sets the ID field of the mutation.
func withInheritanceRelationshipID(id int) inheritancerelationshipOption {
	return func(m *InheritanceRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *InheritanceRelationship
		)
		m.oldValue = func(ctx context.Context) (*InheritanceRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InheritanceRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInheritanceRelationship sets the old InheritanceRelationship of the mutation.
func withInheritanceRelationship(node *InheritanceRelationship) inheritancerelationshipOption {
	return func(m *InheritanceRelationshipMutation) {
		m.oldValue = func(context.Context) (*InheritanceRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InheritanceRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InheritanceRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InheritanceRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InheritanceRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InheritanceRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRelationshipType sets the "relationship_type" field.
func (m *InheritanceRelationshipMutation) SetRelationshipType(it inheritancerelationship.RelationshipType) {
	m.relationship_type = &it
}

// RelationshipType returns the value of the "relationship_type" field in the mutation.
func (m *InheritanceRelationshipMutation) RelationshipType() (r inheritancerelationship.RelationshipType, exists bool) {
	v := m.relationship_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipType returns the old "relationship_type" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldRelationshipType(ctx context.Context) (v inheritancerelationship.RelationshipType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipType: %w", err)
	}
	return oldValue.RelationshipType, nil
}

// ResetRelationshipType resets all changes to the "relationship_type" field.
func (m *InheritanceRelationshipMutation) ResetRelationshipType() {
	m.relationship_type = nil
}

// SetLineNumber sets the "line_number" field.
func (m *InheritanceRelationshipMutation) SetLineNumber(i int) {
	m.line_number = &i
	m.addline_number = nil
}

// LineNumber returns the value of the "line_number" field in the mutation.
func (m *InheritanceRelationshipMutation) LineNumber() (r int, exists bool) {
	v := m.line_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNumber returns the old "line_number" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldLineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNumber: %w", err)
	}
	return oldValue.LineNumber, nil
}

// AddLineNumber adds i to the "line_number" field.
func (m *InheritanceRelationshipMutation) AddLineNumber(i int) {
	if m.addline_number != nil {
		*m.addline_number += i
	} else {
		m.addline_number = &i
	}
}

// AddedLineNumber returns the value that was added to the "line_number" field in this mutation.
func (m *InheritanceRelationshipMutation) AddedLineNumber() (r int, exists bool) {
	v := m.addline_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNumber resets all changes to the "line_number" field.
func (m *InheritanceRelationshipMutation) ResetLineNumber() {
	m.line_number = nil
	m.addline_number = nil
}

// SetIsDirectInheritance sets the "is_direct_inheritance" field.
func (m *InheritanceRelationshipMutation) SetIsDirectInheritance(b bool) {
	m.is_direct_inheritance = &b
}

// IsDirectInheritance returns the value of the "is_direct_inheritance" field in the mutation.
func (m *InheritanceRelationshipMutation) IsDirectInheritance() (r bool, exists bool) {
	v := m.is_direct_inheritance
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDirectInheritance returns the old "is_direct_inheritance" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldIsDirectInheritance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDirectInheritance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDirectInheritance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDirectInheritance: %w", err)
	}
	return oldValue.IsDirectInheritance, nil
}

// ResetIsDirectInheritance resets all changes to the "is_direct_inheritance" field.
func (m *InheritanceRelationshipMutation) ResetIsDirectInheritance() {
	m.is_direct_inheritance = nil
}

// SetInheritanceDepth sets the "inheritance_depth" field.
func (m *InheritanceRelationshipMutation) SetInheritanceDepth(i int) {
	m.inheritance_depth = &i
	m.addinheritance_depth = nil
}

// InheritanceDepth returns the value of the "inheritance_depth" field in the mutation.
func (m *InheritanceRelationshipMutation) InheritanceDepth() (r int, exists bool) {
	v := m.inheritance_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritanceDepth returns the old "inheritance_depth" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldInheritanceDepth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritanceDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritanceDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritanceDepth: %w", err)
	}
	return oldValue.InheritanceDepth, nil
}

// AddInheritanceDepth adds i to the "inheritance_depth" field.
func (m *InheritanceRelationshipMutation) AddInheritanceDepth(i int) {
	if m.addinheritance_depth != nil {
		*m.addinheritance_depth += i
	} else {
		m.addinheritance_depth = &i
	}
}

// AddedInheritanceDepth returns the value that was added to the "inheritance_depth" field in this mutation.
func (m *InheritanceRelationshipMutation) AddedInheritanceDepth() (r int, exists bool) {
	v := m.addinheritance_depth
	if v == nil {
		return
	}
	return *v, true
}

// ResetInheritanceDepth resets all changes to the "inheritance_depth" field.
func (m *InheritanceRelationshipMutation) ResetInheritanceDepth() {
	m.inheritance_depth = nil
	m.addinheritance_depth = nil
}

// SetModuleName sets the "module_name" field.
func (m *InheritanceRelationshipMutation) SetModuleName(s string) {
	m.module_name = &s
}

// ModuleName returns the value of the "module_name" field in the mutation.
func (m *InheritanceRelationshipMutation) ModuleName() (r string, exists bool) {
	v := m.module_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleName returns the old "module_name" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldModuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleName: %w", err)
	}
	return oldValue.ModuleName, nil
}

// ClearModuleName clears the value of the "module_name" field.
func (m *InheritanceRelationshipMutation) ClearModuleName() {
	m.module_name = nil
	m.clearedFields[inheritancerelationship.FieldModuleName] = struct{}{}
}

// ModuleNameCleared returns if the "module_name" field was cleared in this mutation.
func (m *InheritanceRelationshipMutation) ModuleNameCleared() bool {
	_, ok := m.clearedFields[inheritancerelationship.FieldModuleName]
	return ok
}

// ResetModuleName resets all changes to the "module_name" field.
func (m *InheritanceRelationshipMutation) ResetModuleName() {
	m.module_name = nil
	delete(m.clearedFields, inheritancerelationship.FieldModuleName)
}

// SetCreatedAt sets the "created_at" field.
func (m *InheritanceRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InheritanceRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InheritanceRelationship entity.
// If the InheritanceRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InheritanceRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InheritanceRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetChildID sets the "child" edge to the Symbol entity by id.
func (m *InheritanceRelationshipMutation) SetChildID(id int) {
	m.child = &id
}

// ClearChild clears the "child" edge to the Symbol entity.
func (m *InheritanceRelationshipMutation) ClearChild() {
	m.clearedchild = true
}

// ChildCleared reports if the "child" edge to the Symbol entity was cleared.
func (m *InheritanceRelationshipMutation) ChildCleared() bool {
	return m.clearedchild
}

// ChildID returns the "child" edge ID in the mutation.
func (m *InheritanceRelationshipMutation) ChildID() (id int, exists bool) {
	if m.child != nil {
		return *m.child, true
	}
	return
}

// ChildIDs returns the "child" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChildID instead. It exists only for internal usage by the builders.
func (m *InheritanceRelationshipMutation) ChildIDs() (ids []int) {
	if id := m.child; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChild resets all changes to the "child" edge.
func (m *InheritanceRelationshipMutation) ResetChild() {
	m.child = nil
	m.clearedchild = false
}

// SetParentID sets the "parent" edge to the Symbol entity by id.
func (m *InheritanceRelationshipMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Symbol entity.
func (m *InheritanceRelationshipMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Symbol entity was cleared.
func (m *InheritanceRelationshipMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *InheritanceRelationshipMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *InheritanceRelationshipMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *InheritanceRelationshipMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *InheritanceRelationshipMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *InheritanceRelationshipMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *InheritanceRelationshipMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *InheritanceRelationshipMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *InheritanceRelationshipMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *InheritanceRelationshipMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the InheritanceRelationshipMutation builder.
func (m *InheritanceRelationshipMutation) Where(ps ...predicate.InheritanceRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InheritanceRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InheritanceRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InheritanceRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InheritanceRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InheritanceRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InheritanceRelationship).
func (m *InheritanceRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InheritanceRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.relationship_type != nil {
		fields = append(fields, inheritancerelationship.FieldRelationshipType)
	}
	if m.line_number != nil {
		fields = append(fields, inheritancerelationship.FieldLineNumber)
	}
	if m.is_direct_inheritance != nil {
		fields = append(fields, inheritancerelationship.FieldIsDirectInheritance)
	}
	if m.inheritance_depth != nil {
		fields = append(fields, inheritancerelationship.FieldInheritanceDepth)
	}
	if m.module_name != nil {
		fields = append(fields, inheritancerelationship.FieldModuleName)
	}
	if m.created_at != nil {
		fields = append(fields, inheritancerelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InheritanceRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inheritancerelationship.FieldRelationshipType:
		return m.RelationshipType()
	case inheritancerelationship.FieldLineNumber:
		return m.LineNumber()
	case inheritancerelationship.FieldIsDirectInheritance:
		return m.IsDirectInheritance()
	case inheritancerelationship.FieldInheritanceDepth:
		return m.InheritanceDepth()
	case inheritancerelationship.FieldModuleName:
		return m.ModuleName()
	case inheritancerelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InheritanceRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inheritancerelationship.FieldRelationshipType:
		return m.OldRelationshipType(ctx)
	case inheritancerelationship.FieldLineNumber:
		return m.OldLineNumber(ctx)
	case inheritancerelationship.FieldIsDirectInheritance:
		return m.OldIsDirectInheritance(ctx)
	case inheritancerelationship.FieldInheritanceDepth:
		return m.OldInheritanceDepth(ctx)
	case inheritancerelationship.FieldModuleName:
		return m.OldModuleName(ctx)
	case inheritancerelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InheritanceRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InheritanceRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inheritancerelationship.FieldRelationshipType:
		v, ok := value.(inheritancerelationship.RelationshipType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipType(v)
		return nil
	case inheritancerelationship.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNumber(v)
		return nil
	case inheritancerelationship.FieldIsDirectInheritance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDirectInheritance(v)
		return nil
	case inheritancerelationship.FieldInheritanceDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritanceDepth(v)
		return nil
	case inheritancerelationship.FieldModuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleName(v)
		return nil
	case inheritancerelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InheritanceRelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addline_number != nil {
		fields = append(fields, inheritancerelationship.FieldLineNumber)
	}
	if m.addinheritance_depth != nil {
		fields = append(fields, inheritancerelationship.FieldInheritanceDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InheritanceRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inheritancerelationship.FieldLineNumber:
		return m.AddedLineNumber()
	case inheritancerelationship.FieldInheritanceDepth:
		return m.AddedInheritanceDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InheritanceRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inheritancerelationship.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNumber(v)
		return nil
	case inheritancerelationship.FieldInheritanceDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInheritanceDepth(v)
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InheritanceRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inheritancerelationship.FieldModuleName) {
		fields = append(fields, inheritancerelationship.FieldModuleName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InheritanceRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InheritanceRelationshipMutation) ClearField(name string) error {
	switch name {
	case inheritancerelationship.FieldModuleName:
		m.ClearModuleName()
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InheritanceRelationshipMutation) ResetField(name string) error {
	switch name {
	case inheritancerelationship.FieldRelationshipType:
		m.ResetRelationshipType()
		return nil
	case inheritancerelationship.FieldLineNumber:
		m.ResetLineNumber()
		return nil
	case inheritancerelationship.FieldIsDirectInheritance:
		m.ResetIsDirectInheritance()
		return nil
	case inheritancerelationship.FieldInheritanceDepth:
		m.ResetInheritanceDepth()
		return nil
	case inheritancerelationship.FieldModuleName:
		m.ResetModuleName()
		return nil
	case inheritancerelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InheritanceRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.child != nil {
		edges = append(edges, inheritancerelationship.EdgeChild)
	}
	if m.parent != nil {
		edges = append(edges, inheritancerelationship.EdgeParent)
	}
	if m.file != nil {
		edges = append(edges, inheritancerelationship.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InheritanceRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inheritancerelationship.EdgeChild:
		if id := m.child; id != nil {
			return []ent.Value{*id}
		}
	case inheritancerelationship.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case inheritancerelationship.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InheritanceRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InheritanceRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InheritanceRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchild {
		edges = append(edges, inheritancerelationship.EdgeChild)
	}
	if m.clearedparent {
		edges = append(edges, inheritancerelationship.EdgeParent)
	}
	if m.clearedfile {
		edges = append(edges, inheritancerelationship.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InheritanceRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case inheritancerelationship.EdgeChild:
		return m.clearedchild
	case inheritancerelationship.EdgeParent:
		return m.clearedparent
	case inheritancerelationship.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InheritanceRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case inheritancerelationship.EdgeChild:
		m.ClearChild()
		return nil
	case inheritancerelationship.EdgeParent:
		m.ClearParent()
		return nil
	case inheritancerelationship.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InheritanceRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case inheritancerelationship.EdgeChild:
		m.ResetChild()
		return nil
	case inheritancerelationship.EdgeParent:
		m.ResetParent()
		return nil
	case inheritancerelationship.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown InheritanceRelationship edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	root_path     *string
	git_hash      *string
	scanned_at    *time.Time
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	files         map[int]struct{}
	removedfiles  map[int]struct{}
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*Project, error)
	predicates    []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetRootPath sets the "root_path" field.
func (m *ProjectMutation) SetRootPath(s string) {
	m.root_path = &s
}

// RootPath returns the value of the "root_path" field in the mutation.
func (m *ProjectMutation) RootPath() (r string, exists bool) {
	v := m.root_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPath returns the old "root_path" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRootPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPath: %w", err)
	}
	return oldValue.RootPath, nil
}

// ResetRootPath resets all changes to the "root_path" field.
func (m *ProjectMutation) ResetRootPath() {
	m.root_path = nil
}

// SetGitHash sets the "git_hash" field.
func (m *ProjectMutation) SetGitHash(s string) {
	m.git_hash = &s
}

// GitHash returns the value of the "git_hash" field in the mutation.
func (m *ProjectMutation) GitHash() (r string, exists bool) {
	v := m.git_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldGitHash returns the old "git_hash" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitHash: %w", err)
	}
	return oldValue.GitHash, nil
}

// ClearGitHash clears the value of the "git_hash" field.
func (m *ProjectMutation) ClearGitHash() {
	m.git_hash = nil
	m.clearedFields[project.FieldGitHash] = struct{}{}
}

// GitHashCleared returns if the "git_hash" field was cleared in this mutation.
func (m *ProjectMutation) GitHashCleared() bool {
	_, ok := m.clearedFields[project.FieldGitHash]
	return ok
}

// ResetGitHash resets all changes to the "git_hash" field.
func (m *ProjectMutation) ResetGitHash() {
	m.git_hash = nil
	delete(m.clearedFields, project.FieldGitHash)
}

// SetScannedAt sets the "scanned_at" field.
func (m *ProjectMutation) SetScannedAt(t time.Time) {
	m.scanned_at = &t
}

// ScannedAt returns the value of the "scanned_at" field in the mutation.
func (m *ProjectMutation) ScannedAt() (r time.Time, exists bool) {
	v := m.scanned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScannedAt returns the old "scanned_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldScannedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannedAt: %w", err)
	}
	return oldValue.ScannedAt, nil
}

// ResetScannedAt resets all changes to the "scanned_at" field.
func (m *ProjectMutation) ResetScannedAt() {
	m.scanned_at = nil
}

// SetMetadata sets the "metadata" field.
func (m *ProjectMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ProjectMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ProjectMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[project.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ProjectMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[project.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ProjectMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, project.FieldMetadata)
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *ProjectMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *ProjectMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *ProjectMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *ProjectMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *ProjectMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *ProjectMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *ProjectMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.root_path != nil {
		fields = append(fields, project.FieldRootPath)
	}
	if m.git_hash != nil {
		fields = append(fields, project.FieldGitHash)
	}
	if m.scanned_at != nil {
		fields = append(fields, project.FieldScannedAt)
	}
	if m.metadata != nil {
		fields = append(fields, project.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldRootPath:
		return m.RootPath()
	case project.FieldGitHash:
		return m.GitHash()
	case project.FieldScannedAt:
		return m.ScannedAt()
	case project.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldRootPath:
		return m.OldRootPath(ctx)
	case project.FieldGitHash:
		return m.OldGitHash(ctx)
	case project.FieldScannedAt:
		return m.OldScannedAt(ctx)
	case project.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldRootPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPath(v)
		return nil
	case project.FieldGitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitHash(v)
		return nil
	case project.FieldScannedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannedAt(v)
		return nil
	case project.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldGitHash) {
		fields = append(fields, project.FieldGitHash)
	}
	if m.FieldCleared(project.FieldMetadata) {
		fields = append(fields, project.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldGitHash:
		m.ClearGitHash()
		return nil
	case project.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldRootPath:
		m.ResetRootPath()
		return nil
	case project.FieldGitHash:
		m.ResetGitHash()
		return nil
	case project.FieldScannedAt:
		m.ResetScannedAt()
		return nil
	case project.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.files != nil {
		edges = append(edges, project.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfiles != nil {
		edges = append(edges, project.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfiles {
		edges = append(edges, project.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// SymbolMutation represents an operation that mutates the Symbol nodes in the graph.
type SymbolMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	qualified_name           *string
	symbol_type              *symbol.SymbolType
	scope_type               *symbol.ScopeType
	access_modifier          *symbol.AccessModifier
	is_static                *bool
	is_abstract              *bool
	is_async                 *bool
	line_number              *int
	addline_number           *int
	column_number            *int
	addcolumn_number         *int
	metadata                 *map[string]interface{}
	created_at               *time.Time
	clearedFields            map[string]struct{}
	file                     *int
	clearedfile              bool
	ast_node                 *int
	clearedast_node          bool
	calls_made               map[int]struct{}
	removedcalls_made        map[int]struct{}
	clearedcalls_made        bool
	calls_received           map[int]struct{}
	removedcalls_received    map[int]struct{}
	clearedcalls_received    bool
	references               map[int]struct{}
	removedreferences        map[int]struct{}
	clearedreferences        bool
	child_classes            map[int]struct{}
	removedchild_classes     map[int]struct{}
	clearedchild_classes     bool
	parent_classes           map[int]struct{}
	removedparent_classes    map[int]struct{}
	clearedparent_classes    bool
	import_references        map[int]struct{}
	removedimport_references map[int]struct{}
	clearedimport_references bool
	done                     bool
	oldValue                 func(context.Context) (*Symbol, error)
	predicates               []predicate.Symbol
}

var _ ent.Mutation = (*SymbolMutation)(nil)

// symbolOption allows management of the mutation configuration using functional options.
type symbolOption func(*SymbolMutation)

// newSymbolMutation creates new mutation for the Symbol entity.
func newSymbolMutation(c config, op Op, opts ...symbolOption) *SymbolMutation {
	m := &SymbolMutation{
		config:        c,
		op:            op,
		typ:           TypeSymbol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymbolID sets the ID field of the mutation.
func withSymbolID(id int) symbolOption {
	return func(m *SymbolMutation) {
		var (
			err   error
			once  sync.Once
			value *Symbol
		)
		m.oldValue = func(ctx context.Context) (*Symbol, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symbol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymbol sets the old Symbol of the mutation.
func withSymbol(node *Symbol) symbolOption {
	return func(m *SymbolMutation) {
		m.oldValue = func(context.Context) (*Symbol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymbolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymbolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SymbolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SymbolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Symbol.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SymbolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SymbolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SymbolMutation) ResetName() {
	m.name = nil
}

// SetQualifiedName sets the "qualified_name" field.
func (m *SymbolMutation) SetQualifiedName(s string) {
	m.qualified_name = &s
}

// QualifiedName returns the value of the "qualified_name" field in the mutation.
func (m *SymbolMutation) QualifiedName() (r string, exists bool) {
	v := m.qualified_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiedName returns the old "qualified_name" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldQualifiedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiedName: %w", err)
	}
	return oldValue.QualifiedName, nil
}

// ResetQualifiedName resets all changes to the "qualified_name" field.
func (m *SymbolMutation) ResetQualifiedName() {
	m.qualified_name = nil
}

// SetSymbolType sets the "symbol_type" field.
func (m *SymbolMutation) SetSymbolType(st symbol.SymbolType) {
	m.symbol_type = &st
}

// SymbolType returns the value of the "symbol_type" field in the mutation.
func (m *SymbolMutation) SymbolType() (r symbol.SymbolType, exists bool) {
	v := m.symbol_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbolType returns the old "symbol_type" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldSymbolType(ctx context.Context) (v symbol.SymbolType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbolType: %w", err)
	}
	return oldValue.SymbolType, nil
}

// ResetSymbolType resets all changes to the "symbol_type" field.
func (m *SymbolMutation) ResetSymbolType() {
	m.symbol_type = nil
}

// SetScopeType sets the "scope_type" field.
func (m *SymbolMutation) SetScopeType(st symbol.ScopeType) {
	m.scope_type = &st
}

// ScopeType returns the value of the "scope_type" field in the mutation.
func (m *SymbolMutation) ScopeType() (r symbol.ScopeType, exists bool) {
	v := m.scope_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeType returns the old "scope_type" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldScopeType(ctx context.Context) (v symbol.ScopeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeType: %w", err)
	}
	return oldValue.ScopeType, nil
}

// ResetScopeType resets all changes to the "scope_type" field.
func (m *SymbolMutation) ResetScopeType() {
	m.scope_type = nil
}

// SetAccessModifier sets the "access_modifier" field.
func (m *SymbolMutation) SetAccessModifier(sm symbol.AccessModifier) {
	m.access_modifier = &sm
}

// AccessModifier returns the value of the "access_modifier" field in the mutation.
func (m *SymbolMutation) AccessModifier() (r symbol.AccessModifier, exists bool) {
	v := m.access_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessModifier returns the old "access_modifier" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldAccessModifier(ctx context.Context) (v symbol.AccessModifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessModifier: %w", err)
	}
	return oldValue.AccessModifier, nil
}

// ClearAccessModifier clears the value of the "access_modifier" field.
func (m *SymbolMutation) ClearAccessModifier() {
	m.access_modifier = nil
	m.clearedFields[symbol.FieldAccessModifier] = struct{}{}
}

// AccessModifierCleared returns if the "access_modifier" field was cleared in this mutation.
func (m *SymbolMutation) AccessModifierCleared() bool {
	_, ok := m.clearedFields[symbol.FieldAccessModifier]
	return ok
}

// ResetAccessModifier resets all changes to the "access_modifier" field.
func (m *SymbolMutation) ResetAccessModifier() {
	m.access_modifier = nil
	delete(m.clearedFields, symbol.FieldAccessModifier)
}

// SetIsStatic sets the "is_static" field.
func (m *SymbolMutation) SetIsStatic(b bool) {
	m.is_static = &b
}

// IsStatic returns the value of the "is_static" field in the mutation.
func (m *SymbolMutation) IsStatic() (r bool, exists bool) {
	v := m.is_static
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStatic returns the old "is_static" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldIsStatic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStatic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStatic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStatic: %w", err)
	}
	return oldValue.IsStatic, nil
}

// ResetIsStatic resets all changes to the "is_static" field.
func (m *SymbolMutation) ResetIsStatic() {
	m.is_static = nil
}

// SetIsAbstract sets the "is_abstract" field.
func (m *SymbolMutation) SetIsAbstract(b bool) {
	m.is_abstract = &b
}

// IsAbstract returns the value of the "is_abstract" field in the mutation.
func (m *SymbolMutation) IsAbstract() (r bool, exists bool) {
	v := m.is_abstract
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAbstract returns the old "is_abstract" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldIsAbstract(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAbstract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAbstract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAbstract: %w", err)
	}
	return oldValue.IsAbstract, nil
}

// ResetIsAbstract resets all changes to the "is_abstract" field.
func (m *SymbolMutation) ResetIsAbstract() {
	m.is_abstract = nil
}

// SetIsAsync sets the "is_async" field.
func (m *SymbolMutation) SetIsAsync(b bool) {
	m.is_async = &b
}

// IsAsync returns the value of the "is_async" field in the mutation.
func (m *SymbolMutation) IsAsync() (r bool, exists bool) {
	v := m.is_async
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAsync returns the old "is_async" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldIsAsync(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAsync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAsync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAsync: %w", err)
	}
	return oldValue.IsAsync, nil
}

// ResetIsAsync resets all changes to the "is_async" field.
func (m *SymbolMutation) ResetIsAsync() {
	m.is_async = nil
}

// SetLineNumber sets the "line_number" field.
func (m *SymbolMutation) SetLineNumber(i int) {
	m.line_number = &i
	m.addline_number = nil
}

// LineNumber returns the value of the "line_number" field in the mutation.
func (m *SymbolMutation) LineNumber() (r int, exists bool) {
	v := m.line_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNumber returns the old "line_number" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldLineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNumber: %w", err)
	}
	return oldValue.LineNumber, nil
}

// AddLineNumber adds i to the "line_number" field.
func (m *SymbolMutation) AddLineNumber(i int) {
	if m.addline_number != nil {
		*m.addline_number += i
	} else {
		m.addline_number = &i
	}
}

// AddedLineNumber returns the value that was added to the "line_number" field in this mutation.
func (m *SymbolMutation) AddedLineNumber() (r int, exists bool) {
	v := m.addline_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNumber resets all changes to the "line_number" field.
func (m *SymbolMutation) ResetLineNumber() {
	m.line_number = nil
	m.addline_number = nil
}

// SetColumnNumber sets the "column_number" field.
func (m *SymbolMutation) SetColumnNumber(i int) {
	m.column_number = &i
	m.addcolumn_number = nil
}

// ColumnNumber returns the value of the "column_number" field in the mutation.
func (m *SymbolMutation) ColumnNumber() (r int, exists bool) {
	v := m.column_number
	if v == nil {
		return
	}
	return *v, true
}

// OldColumnNumber returns the old "column_number" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldColumnNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColumnNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColumnNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColumnNumber: %w", err)
	}
	return oldValue.ColumnNumber, nil
}

// AddColumnNumber adds i to the "column_number" field.
func (m *SymbolMutation) AddColumnNumber(i int) {
	if m.addcolumn_number != nil {
		*m.addcolumn_number += i
	} else {
		m.addcolumn_number = &i
	}
}

// AddedColumnNumber returns the value that was added to the "column_number" field in this mutation.
func (m *SymbolMutation) AddedColumnNumber() (r int, exists bool) {
	v := m.addcolumn_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetColumnNumber resets all changes to the "column_number" field.
func (m *SymbolMutation) ResetColumnNumber() {
	m.column_number = nil
	m.addcolumn_number = nil
}

// SetMetadata sets the "metadata" field.
func (m *SymbolMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SymbolMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SymbolMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[symbol.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SymbolMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[symbol.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SymbolMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, symbol.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *SymbolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SymbolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Symbol entity.
// If the Symbol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SymbolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *SymbolMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *SymbolMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *SymbolMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *SymbolMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *SymbolMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *SymbolMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetAstNodeID sets the "ast_node" edge to the ASTNode entity by id.
func (m *SymbolMutation) SetAstNodeID(id int) {
	m.ast_node = &id
}

// ClearAstNode clears the "ast_node" edge to the ASTNode entity.
func (m *SymbolMutation) ClearAstNode() {
	m.clearedast_node = true
}

// AstNodeCleared reports if the "ast_node" edge to the ASTNode entity was cleared.
func (m *SymbolMutation) AstNodeCleared() bool {
	return m.clearedast_node
}

// AstNodeID returns the "ast_node" edge ID in the mutation.
func (m *SymbolMutation) AstNodeID() (id int, exists bool) {
	if m.ast_node != nil {
		return *m.ast_node, true
	}
	return
}

// AstNodeIDs returns the "ast_node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AstNodeID instead. It exists only for internal usage by the builders.
func (m *SymbolMutation) AstNodeIDs() (ids []int) {
	if id := m.ast_node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAstNode resets all changes to the "ast_node" edge.
func (m *SymbolMutation) ResetAstNode() {
	m.ast_node = nil
	m.clearedast_node = false
}

// AddCallsMadeIDs adds the "calls_made" edge to the CallRelationship entity by ids.
func (m *SymbolMutation) AddCallsMadeIDs(ids ...int) {
	if m.calls_made == nil {
		m.calls_made = make(map[int]struct{})
	}
	for i := range ids {
		m.calls_made[ids[i]] = struct{}{}
	}
}

// ClearCallsMade clears the "calls_made" edge to the CallRelationship entity.
func (m *SymbolMutation) ClearCallsMade() {
	m.clearedcalls_made = true
}

// CallsMadeCleared reports if the "calls_made" edge to the CallRelationship entity was cleared.
func (m *SymbolMutation) CallsMadeCleared() bool {
	return m.clearedcalls_made
}

// RemoveCallsMadeIDs removes the "calls_made" edge to the CallRelationship entity by IDs.
func (m *SymbolMutation) RemoveCallsMadeIDs(ids ...int) {
	if m.removedcalls_made == nil {
		m.removedcalls_made = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.calls_made, ids[i])
		m.removedcalls_made[ids[i]] = struct{}{}
	}
}

// RemovedCallsMade returns the removed IDs of the "calls_made" edge to the CallRelationship entity.
func (m *SymbolMutation) RemovedCallsMadeIDs() (ids []int) {
	for id := range m.removedcalls_made {
		ids = append(ids, id)
	}
	return
}

// CallsMadeIDs returns the "calls_made" edge IDs in the mutation.
func (m *SymbolMutation) CallsMadeIDs() (ids []int) {
	for id := range m.calls_made {
		ids = append(ids, id)
	}
	return
}

// ResetCallsMade resets all changes to the "calls_made" edge.
func (m *SymbolMutation) ResetCallsMade() {
	m.calls_made = nil
	m.clearedcalls_made = false
	m.removedcalls_made = nil
}

// AddCallsReceivedIDs adds the "calls_received" edge to the CallRelationship entity by ids.
func (m *SymbolMutation) AddCallsReceivedIDs(ids ...int) {
	if m.calls_received == nil {
		m.calls_received = make(map[int]struct{})
	}
	for i := range ids {
		m.calls_received[ids[i]] = struct{}{}
	}
}

// ClearCallsReceived clears the "calls_received" edge to the CallRelationship entity.
func (m *SymbolMutation) ClearCallsReceived() {
	m.clearedcalls_received = true
}

// CallsReceivedCleared reports if the "calls_received" edge to the CallRelationship entity was cleared.
func (m *SymbolMutation) CallsReceivedCleared() bool {
	return m.clearedcalls_received
}

// RemoveCallsReceivedIDs removes the "calls_received" edge to the CallRelationship entity by IDs.
func (m *SymbolMutation) RemoveCallsReceivedIDs(ids ...int) {
	if m.removedcalls_received == nil {
		m.removedcalls_received = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.calls_received, ids[i])
		m.removedcalls_received[ids[i]] = struct{}{}
	}
}

// RemovedCallsReceived returns the removed IDs of the "calls_received" edge to the CallRelationship entity.
func (m *SymbolMutation) RemovedCallsReceivedIDs() (ids []int) {
	for id := range m.removedcalls_received {
		ids = append(ids, id)
	}
	return
}

// CallsReceivedIDs returns the "calls_received" edge IDs in the mutation.
func (m *SymbolMutation) CallsReceivedIDs() (ids []int) {
	for id := range m.calls_received {
		ids = append(ids, id)
	}
	return
}

// ResetCallsReceived resets all changes to the "calls_received" edge.
func (m *SymbolMutation) ResetCallsReceived() {
	m.calls_received = nil
	m.clearedcalls_received = false
	m.removedcalls_received = nil
}

// AddReferenceIDs adds the "references" edge to the SymbolReference entity by ids.
func (m *SymbolMutation) AddReferenceIDs(ids ...int) {
	if m.references == nil {
		m.references = make(map[int]struct{})
	}
	for i := range ids {
		m.references[ids[i]] = struct{}{}
	}
}

// ClearReferences clears the "references" edge to the SymbolReference entity.
func (m *SymbolMutation) ClearReferences() {
	m.clearedreferences = true
}

// ReferencesCleared reports if the "references" edge to the SymbolReference entity was cleared.
func (m *SymbolMutation) ReferencesCleared() bool {
	return m.clearedreferences
}

// RemoveReferenceIDs removes the "references" edge to the SymbolReference entity by IDs.
func (m *SymbolMutation) RemoveReferenceIDs(ids ...int) {
	if m.removedreferences == nil {
		m.removedreferences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.references, ids[i])
		m.removedreferences[ids[i]] = struct{}{}
	}
}

// RemovedReferences returns the removed IDs of the "references" edge to the SymbolReference entity.
func (m *SymbolMutation) RemovedReferencesIDs() (ids []int) {
	for id := range m.removedreferences {
		ids = append(ids, id)
	}
	return
}

// ReferencesIDs returns the "references" edge IDs in the mutation.
func (m *SymbolMutation) ReferencesIDs() (ids []int) {
	for id := range m.references {
		ids = append(ids, id)
	}
	return
}

// ResetReferences resets all changes to the "references" edge.
func (m *SymbolMutation) ResetReferences() {
	m.references = nil
	m.clearedreferences = false
	m.removedreferences = nil
}

// AddChildClassIDs adds the "child_classes" edge to the InheritanceRelationship entity by ids.
func (m *SymbolMutation) AddChildClassIDs(ids ...int) {
	if m.child_classes == nil {
		m.child_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.child_classes[ids[i]] = struct{}{}
	}
}

// ClearChildClasses clears the "child_classes" edge to the InheritanceRelationship entity.
func (m *SymbolMutation) ClearChildClasses() {
	m.clearedchild_classes = true
}

// ChildClassesCleared reports if the "child_classes" edge to the InheritanceRelationship entity was cleared.
func (m *SymbolMutation) ChildClassesCleared() bool {
	return m.clearedchild_classes
}

// RemoveChildClassIDs removes the "child_classes" edge to the InheritanceRelationship entity by IDs.
func (m *SymbolMutation) RemoveChildClassIDs(ids ...int) {
	if m.removedchild_classes == nil {
		m.removedchild_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_classes, ids[i])
		m.removedchild_classes[ids[i]] = struct{}{}
	}
}

// RemovedChildClasses returns the removed IDs of the "child_classes" edge to the InheritanceRelationship entity.
func (m *SymbolMutation) RemovedChildClassesIDs() (ids []int) {
	for id := range m.removedchild_classes {
		ids = append(ids, id)
	}
	return
}

// ChildClassesIDs returns the "child_classes" edge IDs in the mutation.
func (m *SymbolMutation) ChildClassesIDs() (ids []int) {
	for id := range m.child_classes {
		ids = append(ids, id)
	}
	return
}

// ResetChildClasses resets all changes to the "child_classes" edge.
func (m *SymbolMutation) ResetChildClasses() {
	m.child_classes = nil
	m.clearedchild_classes = false
	m.removedchild_classes = nil
}

// AddParentClassIDs adds the "parent_classes" edge to the InheritanceRelationship entity by ids.
func (m *SymbolMutation) AddParentClassIDs(ids ...int) {
	if m.parent_classes == nil {
		m.parent_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.parent_classes[ids[i]] = struct{}{}
	}
}

// ClearParentClasses clears the "parent_classes" edge to the InheritanceRelationship entity.
func (m *SymbolMutation) ClearParentClasses() {
	m.clearedparent_classes = true
}

// ParentClassesCleared reports if the "parent_classes" edge to the InheritanceRelationship entity was cleared.
func (m *SymbolMutation) ParentClassesCleared() bool {
	return m.clearedparent_classes
}

// RemoveParentClassIDs removes the "parent_classes" edge to the InheritanceRelationship entity by IDs.
func (m *SymbolMutation) RemoveParentClassIDs(ids ...int) {
	if m.removedparent_classes == nil {
		m.removedparent_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parent_classes, ids[i])
		m.removedparent_classes[ids[i]] = struct{}{}
	}
}

// RemovedParentClasses returns the removed IDs of the "parent_classes" edge to the InheritanceRelationship entity.
func (m *SymbolMutation) RemovedParentClassesIDs() (ids []int) {
	for id := range m.removedparent_classes {
		ids = append(ids, id)
	}
	return
}

// ParentClassesIDs returns the "parent_classes" edge IDs in the mutation.
func (m *SymbolMutation) ParentClassesIDs() (ids []int) {
	for id := range m.parent_classes {
		ids = append(ids, id)
	}
	return
}

// ResetParentClasses resets all changes to the "parent_classes" edge.
func (m *SymbolMutation) ResetParentClasses() {
	m.parent_classes = nil
	m.clearedparent_classes = false
	m.removedparent_classes = nil
}

// AddImportReferenceIDs adds the "import_references" edge to the ImportStatement entity by ids.
func (m *SymbolMutation) AddImportReferenceIDs(ids ...int) {
	if m.import_references == nil {
		m.import_references = make(map[int]struct{})
	}
	for i := range ids {
		m.import_references[ids[i]] = struct{}{}
	}
}

// ClearImportReferences clears the "import_references" edge to the ImportStatement entity.
func (m *SymbolMutation) ClearImportReferences() {
	m.clearedimport_references = true
}

// ImportReferencesCleared reports if the "import_references" edge to the ImportStatement entity was cleared.
func (m *SymbolMutation) ImportReferencesCleared() bool {
	return m.clearedimport_references
}

// RemoveImportReferenceIDs removes the "import_references" edge to the ImportStatement entity by IDs.
func (m *SymbolMutation) RemoveImportReferenceIDs(ids ...int) {
	if m.removedimport_references == nil {
		m.removedimport_references = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.import_references, ids[i])
		m.removedimport_references[ids[i]] = struct{}{}
	}
}

// RemovedImportReferences returns the removed IDs of the "import_references" edge to the ImportStatement entity.
func (m *SymbolMutation) RemovedImportReferencesIDs() (ids []int) {
	for id := range m.removedimport_references {
		ids = append(ids, id)
	}
	return
}

// ImportReferencesIDs returns the "import_references" edge IDs in the mutation.
func (m *SymbolMutation) ImportReferencesIDs() (ids []int) {
	for id := range m.import_references {
		ids = append(ids, id)
	}
	return
}

// ResetImportReferences resets all changes to the "import_references" edge.
func (m *SymbolMutation) ResetImportReferences() {
	m.import_references = nil
	m.clearedimport_references = false
	m.removedimport_references = nil
}

// Where appends a list predicates to the SymbolMutation builder.
func (m *SymbolMutation) Where(ps ...predicate.Symbol) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SymbolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SymbolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Symbol, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SymbolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SymbolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Symbol).
func (m *SymbolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SymbolMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, symbol.FieldName)
	}
	if m.qualified_name != nil {
		fields = append(fields, symbol.FieldQualifiedName)
	}
	if m.symbol_type != nil {
		fields = append(fields, symbol.FieldSymbolType)
	}
	if m.scope_type != nil {
		fields = append(fields, symbol.FieldScopeType)
	}
	if m.access_modifier != nil {
		fields = append(fields, symbol.FieldAccessModifier)
	}
	if m.is_static != nil {
		fields = append(fields, symbol.FieldIsStatic)
	}
	if m.is_abstract != nil {
		fields = append(fields, symbol.FieldIsAbstract)
	}
	if m.is_async != nil {
		fields = append(fields, symbol.FieldIsAsync)
	}
	if m.line_number != nil {
		fields = append(fields, symbol.FieldLineNumber)
	}
	if m.column_number != nil {
		fields = append(fields, symbol.FieldColumnNumber)
	}
	if m.metadata != nil {
		fields = append(fields, symbol.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, symbol.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SymbolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldName:
		return m.Name()
	case symbol.FieldQualifiedName:
		return m.QualifiedName()
	case symbol.FieldSymbolType:
		return m.SymbolType()
	case symbol.FieldScopeType:
		return m.ScopeType()
	case symbol.FieldAccessModifier:
		return m.AccessModifier()
	case symbol.FieldIsStatic:
		return m.IsStatic()
	case symbol.FieldIsAbstract:
		return m.IsAbstract()
	case symbol.FieldIsAsync:
		return m.IsAsync()
	case symbol.FieldLineNumber:
		return m.LineNumber()
	case symbol.FieldColumnNumber:
		return m.ColumnNumber()
	case symbol.FieldMetadata:
		return m.Metadata()
	case symbol.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SymbolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symbol.FieldName:
		return m.OldName(ctx)
	case symbol.FieldQualifiedName:
		return m.OldQualifiedName(ctx)
	case symbol.FieldSymbolType:
		return m.OldSymbolType(ctx)
	case symbol.FieldScopeType:
		return m.OldScopeType(ctx)
	case symbol.FieldAccessModifier:
		return m.OldAccessModifier(ctx)
	case symbol.FieldIsStatic:
		return m.OldIsStatic(ctx)
	case symbol.FieldIsAbstract:
		return m.OldIsAbstract(ctx)
	case symbol.FieldIsAsync:
		return m.OldIsAsync(ctx)
	case symbol.FieldLineNumber:
		return m.OldLineNumber(ctx)
	case symbol.FieldColumnNumber:
		return m.OldColumnNumber(ctx)
	case symbol.FieldMetadata:
		return m.OldMetadata(ctx)
	case symbol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Symbol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case symbol.FieldQualifiedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiedName(v)
		return nil
	case symbol.FieldSymbolType:
		v, ok := value.(symbol.SymbolType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbolType(v)
		return nil
	case symbol.FieldScopeType:
		v, ok := value.(symbol.ScopeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeType(v)
		return nil
	case symbol.FieldAccessModifier:
		v, ok := value.(symbol.AccessModifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessModifier(v)
		return nil
	case symbol.FieldIsStatic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStatic(v)
		return nil
	case symbol.FieldIsAbstract:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAbstract(v)
		return nil
	case symbol.FieldIsAsync:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAsync(v)
		return nil
	case symbol.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNumber(v)
		return nil
	case symbol.FieldColumnNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColumnNumber(v)
		return nil
	case symbol.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case symbol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SymbolMutation) AddedFields() []string {
	var fields []string
	if m.addline_number != nil {
		fields = append(fields, symbol.FieldLineNumber)
	}
	if m.addcolumn_number != nil {
		fields = append(fields, symbol.FieldColumnNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SymbolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case symbol.FieldLineNumber:
		return m.AddedLineNumber()
	case symbol.FieldColumnNumber:
		return m.AddedColumnNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case symbol.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNumber(v)
		return nil
	case symbol.FieldColumnNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColumnNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Symbol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SymbolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(symbol.FieldAccessModifier) {
		fields = append(fields, symbol.FieldAccessModifier)
	}
	if m.FieldCleared(symbol.FieldMetadata) {
		fields = append(fields, symbol.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SymbolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymbolMutation) ClearField(name string) error {
	switch name {
	case symbol.FieldAccessModifier:
		m.ClearAccessModifier()
		return nil
	case symbol.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Symbol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SymbolMutation) ResetField(name string) error {
	switch name {
	case symbol.FieldName:
		m.ResetName()
		return nil
	case symbol.FieldQualifiedName:
		m.ResetQualifiedName()
		return nil
	case symbol.FieldSymbolType:
		m.ResetSymbolType()
		return nil
	case symbol.FieldScopeType:
		m.ResetScopeType()
		return nil
	case symbol.FieldAccessModifier:
		m.ResetAccessModifier()
		return nil
	case symbol.FieldIsStatic:
		m.ResetIsStatic()
		return nil
	case symbol.FieldIsAbstract:
		m.ResetIsAbstract()
		return nil
	case symbol.FieldIsAsync:
		m.ResetIsAsync()
		return nil
	case symbol.FieldLineNumber:
		m.ResetLineNumber()
		return nil
	case symbol.FieldColumnNumber:
		m.ResetColumnNumber()
		return nil
	case symbol.FieldMetadata:
		m.ResetMetadata()
		return nil
	case symbol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Symbol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SymbolMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.file != nil {
		edges = append(edges, symbol.EdgeFile)
	}
	if m.ast_node != nil {
		edges = append(edges, symbol.EdgeAstNode)
	}
	if m.calls_made != nil {
		edges = append(edges, symbol.EdgeCallsMade)
	}
	if m.calls_received != nil {
		edges = append(edges, symbol.EdgeCallsReceived)
	}
	if m.references != nil {
		edges = append(edges, symbol.EdgeReferences)
	}
	if m.child_classes != nil {
		edges = append(edges, symbol.EdgeChildClasses)
	}
	if m.parent_classes != nil {
		edges = append(edges, symbol.EdgeParentClasses)
	}
	if m.import_references != nil {
		edges = append(edges, symbol.EdgeImportReferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SymbolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case symbol.EdgeAstNode:
		if id := m.ast_node; id != nil {
			return []ent.Value{*id}
		}
	case symbol.EdgeCallsMade:
		ids := make([]ent.Value, 0, len(m.calls_made))
		for id := range m.calls_made {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeCallsReceived:
		ids := make([]ent.Value, 0, len(m.calls_received))
		for id := range m.calls_received {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.references))
		for id := range m.references {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeChildClasses:
		ids := make([]ent.Value, 0, len(m.child_classes))
		for id := range m.child_classes {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeParentClasses:
		ids := make([]ent.Value, 0, len(m.parent_classes))
		for id := range m.parent_classes {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeImportReferences:
		ids := make([]ent.Value, 0, len(m.import_references))
		for id := range m.import_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SymbolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcalls_made != nil {
		edges = append(edges, symbol.EdgeCallsMade)
	}
	if m.removedcalls_received != nil {
		edges = append(edges, symbol.EdgeCallsReceived)
	}
	if m.removedreferences != nil {
		edges = append(edges, symbol.EdgeReferences)
	}
	if m.removedchild_classes != nil {
		edges = append(edges, symbol.EdgeChildClasses)
	}
	if m.removedparent_classes != nil {
		edges = append(edges, symbol.EdgeParentClasses)
	}
	if m.removedimport_references != nil {
		edges = append(edges, symbol.EdgeImportReferences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SymbolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symbol.EdgeCallsMade:
		ids := make([]ent.Value, 0, len(m.removedcalls_made))
		for id := range m.removedcalls_made {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeCallsReceived:
		ids := make([]ent.Value, 0, len(m.removedcalls_received))
		for id := range m.removedcalls_received {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeReferences:
		ids := make([]ent.Value, 0, len(m.removedreferences))
		for id := range m.removedreferences {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeChildClasses:
		ids := make([]ent.Value, 0, len(m.removedchild_classes))
		for id := range m.removedchild_classes {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeParentClasses:
		ids := make([]ent.Value, 0, len(m.removedparent_classes))
		for id := range m.removedparent_classes {
			ids = append(ids, id)
		}
		return ids
	case symbol.EdgeImportReferences:
		ids := make([]ent.Value, 0, len(m.removedimport_references))
		for id := range m.removedimport_references {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SymbolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedfile {
		edges = append(edges, symbol.EdgeFile)
	}
	if m.clearedast_node {
		edges = append(edges, symbol.EdgeAstNode)
	}
	if m.clearedcalls_made {
		edges = append(edges, symbol.EdgeCallsMade)
	}
	if m.clearedcalls_received {
		edges = append(edges, symbol.EdgeCallsReceived)
	}
	if m.clearedreferences {
		edges = append(edges, symbol.EdgeReferences)
	}
	if m.clearedchild_classes {
		edges = append(edges, symbol.EdgeChildClasses)
	}
	if m.clearedparent_classes {
		edges = append(edges, symbol.EdgeParentClasses)
	}
	if m.clearedimport_references {
		edges = append(edges, symbol.EdgeImportReferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SymbolMutation) EdgeCleared(name string) bool {
	switch name {
	case symbol.EdgeFile:
		return m.clearedfile
	case symbol.EdgeAstNode:
		return m.clearedast_node
	case symbol.EdgeCallsMade:
		return m.clearedcalls_made
	case symbol.EdgeCallsReceived:
		return m.clearedcalls_received
	case symbol.EdgeReferences:
		return m.clearedreferences
	case symbol.EdgeChildClasses:
		return m.clearedchild_classes
	case symbol.EdgeParentClasses:
		return m.clearedparent_classes
	case symbol.EdgeImportReferences:
		return m.clearedimport_references
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SymbolMutation) ClearEdge(name string) error {
	switch name {
	case symbol.EdgeFile:
		m.ClearFile()
		return nil
	case symbol.EdgeAstNode:
		m.ClearAstNode()
		return nil
	}
	return fmt.Errorf("unknown Symbol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SymbolMutation) ResetEdge(name string) error {
	switch name {
	case symbol.EdgeFile:
		m.ResetFile()
		return nil
	case symbol.EdgeAstNode:
		m.ResetAstNode()
		return nil
	case symbol.EdgeCallsMade:
		m.ResetCallsMade()
		return nil
	case symbol.EdgeCallsReceived:
		m.ResetCallsReceived()
		return nil
	case symbol.EdgeReferences:
		m.ResetReferences()
		return nil
	case symbol.EdgeChildClasses:
		m.ResetChildClasses()
		return nil
	case symbol.EdgeParentClasses:
		m.ResetParentClasses()
		return nil
	case symbol.EdgeImportReferences:
		m.ResetImportReferences()
		return nil
	}
	return fmt.Errorf("unknown Symbol edge %s", name)
}

// SymbolReferenceMutation represents an operation that mutates the SymbolReference nodes in the graph.
type SymbolReferenceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	line_number         *int
	addline_number      *int
	column_number       *int
	addcolumn_number    *int
	reference_type      *symbolreference.ReferenceType
	context             *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	symbol              *int
	clearedsymbol       bool
	file                *int
	clearedfile         bool
	context_node        *int
	clearedcontext_node bool
	done                bool
	oldValue            func(context.Context) (*SymbolReference, error)
	predicates          []predicate.SymbolReference
}

var _ ent.Mutation = (*SymbolReferenceMutation)(nil)

// symbolreferenceOption allows management of the mutation configuration using functional options.
type symbolreferenceOption func(*SymbolReferenceMutation)

// newSymbolReferenceMutation creates new mutation for the SymbolReference entity.
func newSymbolReferenceMutation(c config, op Op, opts ...symbolreferenceOption) *SymbolReferenceMutation {
	m := &SymbolReferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeSymbolReference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymbolReferenceID sets the ID field of the mutation.
func withSymbolReferenceID(id int) symbolreferenceOption {
	return func(m *SymbolReferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *SymbolReference
		)
		m.oldValue = func(ctx context.Context) (*SymbolReference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SymbolReference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymbolReference sets the old SymbolReference of the mutation.
func withSymbolReference(node *SymbolReference) symbolreferenceOption {
	return func(m *SymbolReferenceMutation) {
		m.oldValue = func(context.Context) (*SymbolReference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymbolReferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymbolReferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SymbolReferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SymbolReferenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SymbolReference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLineNumber sets the "line_number" field.
func (m *SymbolReferenceMutation) SetLineNumber(i int) {
	m.line_number = &i
	m.addline_number = nil
}

// LineNumber returns the value of the "line_number" field in the mutation.
func (m *SymbolReferenceMutation) LineNumber() (r int, exists bool) {
	v := m.line_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNumber returns the old "line_number" field's value of the SymbolReference entity.
// If the SymbolReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolReferenceMutation) OldLineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNumber: %w", err)
	}
	return oldValue.LineNumber, nil
}

// AddLineNumber adds i to the "line_number" field.
func (m *SymbolReferenceMutation) AddLineNumber(i int) {
	if m.addline_number != nil {
		*m.addline_number += i
	} else {
		m.addline_number = &i
	}
}

// AddedLineNumber returns the value that was added to the "line_number" field in this mutation.
func (m *SymbolReferenceMutation) AddedLineNumber() (r int, exists bool) {
	v := m.addline_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNumber resets all changes to the "line_number" field.
func (m *SymbolReferenceMutation) ResetLineNumber() {
	m.line_number = nil
	m.addline_number = nil
}

// SetColumnNumber sets the "column_number" field.
func (m *SymbolReferenceMutation) SetColumnNumber(i int) {
	m.column_number = &i
	m.addcolumn_number = nil
}

// ColumnNumber returns the value of the "column_number" field in the mutation.
func (m *SymbolReferenceMutation) ColumnNumber() (r int, exists bool) {
	v := m.column_number
	if v == nil {
		return
	}
	return *v, true
}

// OldColumnNumber returns the old "column_number" field's value of the SymbolReference entity.
// If the SymbolReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolReferenceMutation) OldColumnNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColumnNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColumnNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColumnNumber: %w", err)
	}
	return oldValue.ColumnNumber, nil
}

// AddColumnNumber adds i to the "column_number" field.
func (m *SymbolReferenceMutation) AddColumnNumber(i int) {
	if m.addcolumn_number != nil {
		*m.addcolumn_number += i
	} else {
		m.addcolumn_number = &i
	}
}

// AddedColumnNumber returns the value that was added to the "column_number" field in this mutation.
func (m *SymbolReferenceMutation) AddedColumnNumber() (r int, exists bool) {
	v := m.addcolumn_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetColumnNumber resets all changes to the "column_number" field.
func (m *SymbolReferenceMutation) ResetColumnNumber() {
	m.column_number = nil
	m.addcolumn_number = nil
}

// SetReferenceType sets the "reference_type" field.
func (m *SymbolReferenceMutation) SetReferenceType(st symbolreference.ReferenceType) {
	m.reference_type = &st
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *SymbolReferenceMutation) ReferenceType() (r symbolreference.ReferenceType, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the SymbolReference entity.
// If the SymbolReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolReferenceMutation) OldReferenceType(ctx context.Context) (v symbolreference.ReferenceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *SymbolReferenceMutation) ResetReferenceType() {
	m.reference_type = nil
}

// SetContext sets the "context" field.
func (m *SymbolReferenceMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the value of the "context" field in the mutation.
func (m *SymbolReferenceMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the SymbolReference entity.
// If the SymbolReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolReferenceMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *SymbolReferenceMutation) ClearContext() {
	m.context = nil
	m.clearedFields[symbolreference.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *SymbolReferenceMutation) ContextCleared() bool {
	_, ok := m.clearedFields[symbolreference.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *SymbolReferenceMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, symbolreference.FieldContext)
}

// SetCreatedAt sets the "created_at" field.
func (m *SymbolReferenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SymbolReferenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SymbolReference entity.
// If the SymbolReference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SymbolReferenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SymbolReferenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSymbolID sets the "symbol" edge to the Symbol entity by id.
func (m *SymbolReferenceMutation) SetSymbolID(id int) {
	m.symbol = &id
}

// ClearSymbol clears the "symbol" edge to the Symbol entity.
func (m *SymbolReferenceMutation) ClearSymbol() {
	m.clearedsymbol = true
}

// SymbolCleared reports if the "symbol" edge to the Symbol entity was cleared.
func (m *SymbolReferenceMutation) SymbolCleared() bool {
	return m.clearedsymbol
}

// SymbolID returns the "symbol" edge ID in the mutation.
func (m *SymbolReferenceMutation) SymbolID() (id int, exists bool) {
	if m.symbol != nil {
		return *m.symbol, true
	}
	return
}

// SymbolIDs returns the "symbol" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SymbolID instead. It exists only for internal usage by the builders.
func (m *SymbolReferenceMutation) SymbolIDs() (ids []int) {
	if id := m.symbol; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymbol resets all changes to the "symbol" edge.
func (m *SymbolReferenceMutation) ResetSymbol() {
	m.symbol = nil
	m.clearedsymbol = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *SymbolReferenceMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *SymbolReferenceMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *SymbolReferenceMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *SymbolReferenceMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *SymbolReferenceMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *SymbolReferenceMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetContextNodeID sets the "context_node" edge to the ASTNode entity by id.
func (m *SymbolReferenceMutation) SetContextNodeID(id int) {
	m.context_node = &id
}

// ClearContextNode clears the "context_node" edge to the ASTNode entity.
func (m *SymbolReferenceMutation) ClearContextNode() {
	m.clearedcontext_node = true
}

// ContextNodeCleared reports if the "context_node" edge to the ASTNode entity was cleared.
func (m *SymbolReferenceMutation) ContextNodeCleared() bool {
	return m.clearedcontext_node
}

// ContextNodeID returns the "context_node" edge ID in the mutation.
func (m *SymbolReferenceMutation) ContextNodeID() (id int, exists bool) {
	if m.context_node != nil {
		return *m.context_node, true
	}
	return
}

// ContextNodeIDs returns the "context_node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContextNodeID instead. It exists only for internal usage by the builders.
func (m *SymbolReferenceMutation) ContextNodeIDs() (ids []int) {
	if id := m.context_node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContextNode resets all changes to the "context_node" edge.
func (m *SymbolReferenceMutation) ResetContextNode() {
	m.context_node = nil
	m.clearedcontext_node = false
}

// Where appends a list predicates to the SymbolReferenceMutation builder.
func (m *SymbolReferenceMutation) Where(ps ...predicate.SymbolReference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SymbolReferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SymbolReferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SymbolReference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SymbolReferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SymbolReferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SymbolReference).
func (m *SymbolReferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SymbolReferenceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.line_number != nil {
		fields = append(fields, symbolreference.FieldLineNumber)
	}
	if m.column_number != nil {
		fields = append(fields, symbolreference.FieldColumnNumber)
	}
	if m.reference_type != nil {
		fields = append(fields, symbolreference.FieldReferenceType)
	}
	if m.context != nil {
		fields = append(fields, symbolreference.FieldContext)
	}
	if m.created_at != nil {
		fields = append(fields, symbolreference.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SymbolReferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symbolreference.FieldLineNumber:
		return m.LineNumber()
	case symbolreference.FieldColumnNumber:
		return m.ColumnNumber()
	case symbolreference.FieldReferenceType:
		return m.ReferenceType()
	case symbolreference.FieldContext:
		return m.Context()
	case symbolreference.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SymbolReferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symbolreference.FieldLineNumber:
		return m.OldLineNumber(ctx)
	case symbolreference.FieldColumnNumber:
		return m.OldColumnNumber(ctx)
	case symbolreference.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case symbolreference.FieldContext:
		return m.OldContext(ctx)
	case symbolreference.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SymbolReference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolReferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symbolreference.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNumber(v)
		return nil
	case symbolreference.FieldColumnNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColumnNumber(v)
		return nil
	case symbolreference.FieldReferenceType:
		v, ok := value.(symbolreference.ReferenceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case symbolreference.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case symbolreference.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SymbolReference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SymbolReferenceMutation) AddedFields() []string {
	var fields []string
	if m.addline_number != nil {
		fields = append(fields, symbolreference.FieldLineNumber)
	}
	if m.addcolumn_number != nil {
		fields = append(fields, symbolreference.FieldColumnNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SymbolReferenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case symbolreference.FieldLineNumber:
		return m.AddedLineNumber()
	case symbolreference.FieldColumnNumber:
		return m.AddedColumnNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SymbolReferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case symbolreference.FieldLineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNumber(v)
		return nil
	case symbolreference.FieldColumnNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColumnNumber(v)
		return nil
	}
	return fmt.Errorf("unknown SymbolReference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SymbolReferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(symbolreference.FieldContext) {
		fields = append(fields, symbolreference.FieldContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SymbolReferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymbolReferenceMutation) ClearField(name string) error {
	switch name {
	case symbolreference.FieldContext:
		m.ClearContext()
		return nil
	}
	return fmt.Errorf("unknown SymbolReference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SymbolReferenceMutation) ResetField(name string) error {
	switch name {
	case symbolreference.FieldLineNumber:
		m.ResetLineNumber()
		return nil
	case symbolreference.FieldColumnNumber:
		m.ResetColumnNumber()
		return nil
	case symbolreference.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case symbolreference.FieldContext:
		m.ResetContext()
		return nil
	case symbolreference.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SymbolReference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SymbolReferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.symbol != nil {
		edges = append(edges, symbolreference.EdgeSymbol)
	}
	if m.file != nil {
		edges = append(edges, symbolreference.EdgeFile)
	}
	if m.context_node != nil {
		edges = append(edges, symbolreference.EdgeContextNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SymbolReferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symbolreference.EdgeSymbol:
		if id := m.symbol; id != nil {
			return []ent.Value{*id}
		}
	case symbolreference.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case symbolreference.EdgeContextNode:
		if id := m.context_node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SymbolReferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SymbolReferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SymbolReferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsymbol {
		edges = append(edges, symbolreference.EdgeSymbol)
	}
	if m.clearedfile {
		edges = append(edges, symbolreference.EdgeFile)
	}
	if m.clearedcontext_node {
		edges = append(edges, symbolreference.EdgeContextNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SymbolReferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case symbolreference.EdgeSymbol:
		return m.clearedsymbol
	case symbolreference.EdgeFile:
		return m.clearedfile
	case symbolreference.EdgeContextNode:
		return m.clearedcontext_node
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SymbolReferenceMutation) ClearEdge(name string) error {
	switch name {
	case symbolreference.EdgeSymbol:
		m.ClearSymbol()
		return nil
	case symbolreference.EdgeFile:
		m.ClearFile()
		return nil
	case symbolreference.EdgeContextNode:
		m.ClearContextNode()
		return nil
	}
	return fmt.Errorf("unknown SymbolReference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SymbolReferenceMutation) ResetEdge(name string) error {
	switch name {
	case symbolreference.EdgeSymbol:
		m.ResetSymbol()
		return nil
	case symbolreference.EdgeFile:
		m.ResetFile()
		return nil
	case symbolreference.EdgeContextNode:
		m.ResetContextNode()
		return nil
	}
	return fmt.Errorf("unknown SymbolReference edge %s", name)
}
