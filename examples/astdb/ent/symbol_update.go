// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/safedep/code/examples/astdb/ent/astnode"
	"github.com/safedep/code/examples/astdb/ent/callrelationship"
	"github.com/safedep/code/examples/astdb/ent/file"
	"github.com/safedep/code/examples/astdb/ent/importstatement"
	"github.com/safedep/code/examples/astdb/ent/inheritancerelationship"
	"github.com/safedep/code/examples/astdb/ent/predicate"
	"github.com/safedep/code/examples/astdb/ent/symbol"
	"github.com/safedep/code/examples/astdb/ent/symbolreference"
)

// SymbolUpdate is the builder for updating Symbol entities.
type SymbolUpdate struct {
	config
	hooks    []Hook
	mutation *SymbolMutation
}

// Where appends a list predicates to the SymbolUpdate builder.
func (_u *SymbolUpdate) Where(ps ...predicate.Symbol) *SymbolUpdate {
	_u.mutation.Where(ps...)
	return _u
}

// SetName sets the "name" field.
func (_u *SymbolUpdate) SetName(v string) *SymbolUpdate {
	_u.mutation.SetName(v)
	return _u
}

// SetNillableName sets the "name" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableName(v *string) *SymbolUpdate {
	if v != nil {
		_u.SetName(*v)
	}
	return _u
}

// SetQualifiedName sets the "qualified_name" field.
func (_u *SymbolUpdate) SetQualifiedName(v string) *SymbolUpdate {
	_u.mutation.SetQualifiedName(v)
	return _u
}

// SetNillableQualifiedName sets the "qualified_name" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableQualifiedName(v *string) *SymbolUpdate {
	if v != nil {
		_u.SetQualifiedName(*v)
	}
	return _u
}

// SetSymbolType sets the "symbol_type" field.
func (_u *SymbolUpdate) SetSymbolType(v symbol.SymbolType) *SymbolUpdate {
	_u.mutation.SetSymbolType(v)
	return _u
}

// SetNillableSymbolType sets the "symbol_type" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableSymbolType(v *symbol.SymbolType) *SymbolUpdate {
	if v != nil {
		_u.SetSymbolType(*v)
	}
	return _u
}

// SetScopeType sets the "scope_type" field.
func (_u *SymbolUpdate) SetScopeType(v symbol.ScopeType) *SymbolUpdate {
	_u.mutation.SetScopeType(v)
	return _u
}

// SetNillableScopeType sets the "scope_type" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableScopeType(v *symbol.ScopeType) *SymbolUpdate {
	if v != nil {
		_u.SetScopeType(*v)
	}
	return _u
}

// SetAccessModifier sets the "access_modifier" field.
func (_u *SymbolUpdate) SetAccessModifier(v symbol.AccessModifier) *SymbolUpdate {
	_u.mutation.SetAccessModifier(v)
	return _u
}

// SetNillableAccessModifier sets the "access_modifier" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableAccessModifier(v *symbol.AccessModifier) *SymbolUpdate {
	if v != nil {
		_u.SetAccessModifier(*v)
	}
	return _u
}

// ClearAccessModifier clears the value of the "access_modifier" field.
func (_u *SymbolUpdate) ClearAccessModifier() *SymbolUpdate {
	_u.mutation.ClearAccessModifier()
	return _u
}

// SetIsStatic sets the "is_static" field.
func (_u *SymbolUpdate) SetIsStatic(v bool) *SymbolUpdate {
	_u.mutation.SetIsStatic(v)
	return _u
}

// SetNillableIsStatic sets the "is_static" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableIsStatic(v *bool) *SymbolUpdate {
	if v != nil {
		_u.SetIsStatic(*v)
	}
	return _u
}

// SetIsAbstract sets the "is_abstract" field.
func (_u *SymbolUpdate) SetIsAbstract(v bool) *SymbolUpdate {
	_u.mutation.SetIsAbstract(v)
	return _u
}

// SetNillableIsAbstract sets the "is_abstract" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableIsAbstract(v *bool) *SymbolUpdate {
	if v != nil {
		_u.SetIsAbstract(*v)
	}
	return _u
}

// SetIsAsync sets the "is_async" field.
func (_u *SymbolUpdate) SetIsAsync(v bool) *SymbolUpdate {
	_u.mutation.SetIsAsync(v)
	return _u
}

// SetNillableIsAsync sets the "is_async" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableIsAsync(v *bool) *SymbolUpdate {
	if v != nil {
		_u.SetIsAsync(*v)
	}
	return _u
}

// SetLineNumber sets the "line_number" field.
func (_u *SymbolUpdate) SetLineNumber(v int) *SymbolUpdate {
	_u.mutation.ResetLineNumber()
	_u.mutation.SetLineNumber(v)
	return _u
}

// SetNillableLineNumber sets the "line_number" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableLineNumber(v *int) *SymbolUpdate {
	if v != nil {
		_u.SetLineNumber(*v)
	}
	return _u
}

// AddLineNumber adds value to the "line_number" field.
func (_u *SymbolUpdate) AddLineNumber(v int) *SymbolUpdate {
	_u.mutation.AddLineNumber(v)
	return _u
}

// SetColumnNumber sets the "column_number" field.
func (_u *SymbolUpdate) SetColumnNumber(v int) *SymbolUpdate {
	_u.mutation.ResetColumnNumber()
	_u.mutation.SetColumnNumber(v)
	return _u
}

// SetNillableColumnNumber sets the "column_number" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableColumnNumber(v *int) *SymbolUpdate {
	if v != nil {
		_u.SetColumnNumber(*v)
	}
	return _u
}

// AddColumnNumber adds value to the "column_number" field.
func (_u *SymbolUpdate) AddColumnNumber(v int) *SymbolUpdate {
	_u.mutation.AddColumnNumber(v)
	return _u
}

// SetMetadata sets the "metadata" field.
func (_u *SymbolUpdate) SetMetadata(v map[string]interface{}) *SymbolUpdate {
	_u.mutation.SetMetadata(v)
	return _u
}

// ClearMetadata clears the value of the "metadata" field.
func (_u *SymbolUpdate) ClearMetadata() *SymbolUpdate {
	_u.mutation.ClearMetadata()
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *SymbolUpdate) SetCreatedAt(v time.Time) *SymbolUpdate {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *SymbolUpdate) SetNillableCreatedAt(v *time.Time) *SymbolUpdate {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetFileID sets the "file" edge to the File entity by ID.
func (_u *SymbolUpdate) SetFileID(id int) *SymbolUpdate {
	_u.mutation.SetFileID(id)
	return _u
}

// SetNillableFileID sets the "file" edge to the File entity by ID if the given value is not nil.
func (_u *SymbolUpdate) SetNillableFileID(id *int) *SymbolUpdate {
	if id != nil {
		_u = _u.SetFileID(*id)
	}
	return _u
}

// SetFile sets the "file" edge to the File entity.
func (_u *SymbolUpdate) SetFile(v *File) *SymbolUpdate {
	return _u.SetFileID(v.ID)
}

// SetAstNodeID sets the "ast_node" edge to the ASTNode entity by ID.
func (_u *SymbolUpdate) SetAstNodeID(id int) *SymbolUpdate {
	_u.mutation.SetAstNodeID(id)
	return _u
}

// SetNillableAstNodeID sets the "ast_node" edge to the ASTNode entity by ID if the given value is not nil.
func (_u *SymbolUpdate) SetNillableAstNodeID(id *int) *SymbolUpdate {
	if id != nil {
		_u = _u.SetAstNodeID(*id)
	}
	return _u
}

// SetAstNode sets the "ast_node" edge to the ASTNode entity.
func (_u *SymbolUpdate) SetAstNode(v *ASTNode) *SymbolUpdate {
	return _u.SetAstNodeID(v.ID)
}

// AddCallsMadeIDs adds the "calls_made" edge to the CallRelationship entity by IDs.
func (_u *SymbolUpdate) AddCallsMadeIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddCallsMadeIDs(ids...)
	return _u
}

// AddCallsMade adds the "calls_made" edges to the CallRelationship entity.
func (_u *SymbolUpdate) AddCallsMade(v ...*CallRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallsMadeIDs(ids...)
}

// AddCallsReceivedIDs adds the "calls_received" edge to the CallRelationship entity by IDs.
func (_u *SymbolUpdate) AddCallsReceivedIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddCallsReceivedIDs(ids...)
	return _u
}

// AddCallsReceived adds the "calls_received" edges to the CallRelationship entity.
func (_u *SymbolUpdate) AddCallsReceived(v ...*CallRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallsReceivedIDs(ids...)
}

// AddReferenceIDs adds the "references" edge to the SymbolReference entity by IDs.
func (_u *SymbolUpdate) AddReferenceIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddReferenceIDs(ids...)
	return _u
}

// AddReferences adds the "references" edges to the SymbolReference entity.
func (_u *SymbolUpdate) AddReferences(v ...*SymbolReference) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddReferenceIDs(ids...)
}

// AddChildClassIDs adds the "child_classes" edge to the InheritanceRelationship entity by IDs.
func (_u *SymbolUpdate) AddChildClassIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddChildClassIDs(ids...)
	return _u
}

// AddChildClasses adds the "child_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdate) AddChildClasses(v ...*InheritanceRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddChildClassIDs(ids...)
}

// AddParentClassIDs adds the "parent_classes" edge to the InheritanceRelationship entity by IDs.
func (_u *SymbolUpdate) AddParentClassIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddParentClassIDs(ids...)
	return _u
}

// AddParentClasses adds the "parent_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdate) AddParentClasses(v ...*InheritanceRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddParentClassIDs(ids...)
}

// AddImportReferenceIDs adds the "import_references" edge to the ImportStatement entity by IDs.
func (_u *SymbolUpdate) AddImportReferenceIDs(ids ...int) *SymbolUpdate {
	_u.mutation.AddImportReferenceIDs(ids...)
	return _u
}

// AddImportReferences adds the "import_references" edges to the ImportStatement entity.
func (_u *SymbolUpdate) AddImportReferences(v ...*ImportStatement) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddImportReferenceIDs(ids...)
}

// Mutation returns the SymbolMutation object of the builder.
func (_u *SymbolUpdate) Mutation() *SymbolMutation {
	return _u.mutation
}

// ClearFile clears the "file" edge to the File entity.
func (_u *SymbolUpdate) ClearFile() *SymbolUpdate {
	_u.mutation.ClearFile()
	return _u
}

// ClearAstNode clears the "ast_node" edge to the ASTNode entity.
func (_u *SymbolUpdate) ClearAstNode() *SymbolUpdate {
	_u.mutation.ClearAstNode()
	return _u
}

// ClearCallsMade clears all "calls_made" edges to the CallRelationship entity.
func (_u *SymbolUpdate) ClearCallsMade() *SymbolUpdate {
	_u.mutation.ClearCallsMade()
	return _u
}

// RemoveCallsMadeIDs removes the "calls_made" edge to CallRelationship entities by IDs.
func (_u *SymbolUpdate) RemoveCallsMadeIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveCallsMadeIDs(ids...)
	return _u
}

// RemoveCallsMade removes "calls_made" edges to CallRelationship entities.
func (_u *SymbolUpdate) RemoveCallsMade(v ...*CallRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallsMadeIDs(ids...)
}

// ClearCallsReceived clears all "calls_received" edges to the CallRelationship entity.
func (_u *SymbolUpdate) ClearCallsReceived() *SymbolUpdate {
	_u.mutation.ClearCallsReceived()
	return _u
}

// RemoveCallsReceivedIDs removes the "calls_received" edge to CallRelationship entities by IDs.
func (_u *SymbolUpdate) RemoveCallsReceivedIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveCallsReceivedIDs(ids...)
	return _u
}

// RemoveCallsReceived removes "calls_received" edges to CallRelationship entities.
func (_u *SymbolUpdate) RemoveCallsReceived(v ...*CallRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallsReceivedIDs(ids...)
}

// ClearReferences clears all "references" edges to the SymbolReference entity.
func (_u *SymbolUpdate) ClearReferences() *SymbolUpdate {
	_u.mutation.ClearReferences()
	return _u
}

// RemoveReferenceIDs removes the "references" edge to SymbolReference entities by IDs.
func (_u *SymbolUpdate) RemoveReferenceIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveReferenceIDs(ids...)
	return _u
}

// RemoveReferences removes "references" edges to SymbolReference entities.
func (_u *SymbolUpdate) RemoveReferences(v ...*SymbolReference) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveReferenceIDs(ids...)
}

// ClearChildClasses clears all "child_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdate) ClearChildClasses() *SymbolUpdate {
	_u.mutation.ClearChildClasses()
	return _u
}

// RemoveChildClassIDs removes the "child_classes" edge to InheritanceRelationship entities by IDs.
func (_u *SymbolUpdate) RemoveChildClassIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveChildClassIDs(ids...)
	return _u
}

// RemoveChildClasses removes "child_classes" edges to InheritanceRelationship entities.
func (_u *SymbolUpdate) RemoveChildClasses(v ...*InheritanceRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveChildClassIDs(ids...)
}

// ClearParentClasses clears all "parent_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdate) ClearParentClasses() *SymbolUpdate {
	_u.mutation.ClearParentClasses()
	return _u
}

// RemoveParentClassIDs removes the "parent_classes" edge to InheritanceRelationship entities by IDs.
func (_u *SymbolUpdate) RemoveParentClassIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveParentClassIDs(ids...)
	return _u
}

// RemoveParentClasses removes "parent_classes" edges to InheritanceRelationship entities.
func (_u *SymbolUpdate) RemoveParentClasses(v ...*InheritanceRelationship) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveParentClassIDs(ids...)
}

// ClearImportReferences clears all "import_references" edges to the ImportStatement entity.
func (_u *SymbolUpdate) ClearImportReferences() *SymbolUpdate {
	_u.mutation.ClearImportReferences()
	return _u
}

// RemoveImportReferenceIDs removes the "import_references" edge to ImportStatement entities by IDs.
func (_u *SymbolUpdate) RemoveImportReferenceIDs(ids ...int) *SymbolUpdate {
	_u.mutation.RemoveImportReferenceIDs(ids...)
	return _u
}

// RemoveImportReferences removes "import_references" edges to ImportStatement entities.
func (_u *SymbolUpdate) RemoveImportReferences(v ...*ImportStatement) *SymbolUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveImportReferenceIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *SymbolUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *SymbolUpdate) SaveX(ctx context.Context) int {
	affected, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (_u *SymbolUpdate) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *SymbolUpdate) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *SymbolUpdate) check() error {
	if v, ok := _u.mutation.Name(); ok {
		if err := symbol.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Symbol.name": %w`, err)}
		}
	}
	if v, ok := _u.mutation.QualifiedName(); ok {
		if err := symbol.QualifiedNameValidator(v); err != nil {
			return &ValidationError{Name: "qualified_name", err: fmt.Errorf(`ent: validator failed for field "Symbol.qualified_name": %w`, err)}
		}
	}
	if v, ok := _u.mutation.SymbolType(); ok {
		if err := symbol.SymbolTypeValidator(v); err != nil {
			return &ValidationError{Name: "symbol_type", err: fmt.Errorf(`ent: validator failed for field "Symbol.symbol_type": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ScopeType(); ok {
		if err := symbol.ScopeTypeValidator(v); err != nil {
			return &ValidationError{Name: "scope_type", err: fmt.Errorf(`ent: validator failed for field "Symbol.scope_type": %w`, err)}
		}
	}
	if v, ok := _u.mutation.AccessModifier(); ok {
		if err := symbol.AccessModifierValidator(v); err != nil {
			return &ValidationError{Name: "access_modifier", err: fmt.Errorf(`ent: validator failed for field "Symbol.access_modifier": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LineNumber(); ok {
		if err := symbol.LineNumberValidator(v); err != nil {
			return &ValidationError{Name: "line_number", err: fmt.Errorf(`ent: validator failed for field "Symbol.line_number": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ColumnNumber(); ok {
		if err := symbol.ColumnNumberValidator(v); err != nil {
			return &ValidationError{Name: "column_number", err: fmt.Errorf(`ent: validator failed for field "Symbol.column_number": %w`, err)}
		}
	}
	return nil
}

func (_u *SymbolUpdate) sqlSave(ctx context.Context) (_node int, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(symbol.Table, symbol.Columns, sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt))
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.Name(); ok {
		_spec.SetField(symbol.FieldName, field.TypeString, value)
	}
	if value, ok := _u.mutation.QualifiedName(); ok {
		_spec.SetField(symbol.FieldQualifiedName, field.TypeString, value)
	}
	if value, ok := _u.mutation.SymbolType(); ok {
		_spec.SetField(symbol.FieldSymbolType, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.ScopeType(); ok {
		_spec.SetField(symbol.FieldScopeType, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.AccessModifier(); ok {
		_spec.SetField(symbol.FieldAccessModifier, field.TypeEnum, value)
	}
	if _u.mutation.AccessModifierCleared() {
		_spec.ClearField(symbol.FieldAccessModifier, field.TypeEnum)
	}
	if value, ok := _u.mutation.IsStatic(); ok {
		_spec.SetField(symbol.FieldIsStatic, field.TypeBool, value)
	}
	if value, ok := _u.mutation.IsAbstract(); ok {
		_spec.SetField(symbol.FieldIsAbstract, field.TypeBool, value)
	}
	if value, ok := _u.mutation.IsAsync(); ok {
		_spec.SetField(symbol.FieldIsAsync, field.TypeBool, value)
	}
	if value, ok := _u.mutation.LineNumber(); ok {
		_spec.SetField(symbol.FieldLineNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedLineNumber(); ok {
		_spec.AddField(symbol.FieldLineNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.ColumnNumber(); ok {
		_spec.SetField(symbol.FieldColumnNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedColumnNumber(); ok {
		_spec.AddField(symbol.FieldColumnNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.Metadata(); ok {
		_spec.SetField(symbol.FieldMetadata, field.TypeJSON, value)
	}
	if _u.mutation.MetadataCleared() {
		_spec.ClearField(symbol.FieldMetadata, field.TypeJSON)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(symbol.FieldCreatedAt, field.TypeTime, value)
	}
	if _u.mutation.FileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   symbol.FileTable,
			Columns: []string{symbol.FileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.FileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   symbol.FileTable,
			Columns: []string{symbol.FileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.AstNodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   symbol.AstNodeTable,
			Columns: []string{symbol.AstNodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.AstNodeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   symbol.AstNodeTable,
			Columns: []string{symbol.AstNodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallsMadeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallsMadeIDs(); len(nodes) > 0 && !_u.mutation.CallsMadeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallsMadeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallsReceivedCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallsReceivedIDs(); len(nodes) > 0 && !_u.mutation.CallsReceivedCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallsReceivedIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedReferencesIDs(); len(nodes) > 0 && !_u.mutation.ReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ChildClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedChildClassesIDs(); len(nodes) > 0 && !_u.mutation.ChildClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ChildClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ParentClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedParentClassesIDs(); len(nodes) > 0 && !_u.mutation.ParentClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ParentClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ImportReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedImportReferencesIDs(); len(nodes) > 0 && !_u.mutation.ImportReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ImportReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{symbol.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	_u.mutation.done = true
	return _node, nil
}

// SymbolUpdateOne is the builder for updating a single Symbol entity.
type SymbolUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *SymbolMutation
}

// SetName sets the "name" field.
func (_u *SymbolUpdateOne) SetName(v string) *SymbolUpdateOne {
	_u.mutation.SetName(v)
	return _u
}

// SetNillableName sets the "name" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableName(v *string) *SymbolUpdateOne {
	if v != nil {
		_u.SetName(*v)
	}
	return _u
}

// SetQualifiedName sets the "qualified_name" field.
func (_u *SymbolUpdateOne) SetQualifiedName(v string) *SymbolUpdateOne {
	_u.mutation.SetQualifiedName(v)
	return _u
}

// SetNillableQualifiedName sets the "qualified_name" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableQualifiedName(v *string) *SymbolUpdateOne {
	if v != nil {
		_u.SetQualifiedName(*v)
	}
	return _u
}

// SetSymbolType sets the "symbol_type" field.
func (_u *SymbolUpdateOne) SetSymbolType(v symbol.SymbolType) *SymbolUpdateOne {
	_u.mutation.SetSymbolType(v)
	return _u
}

// SetNillableSymbolType sets the "symbol_type" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableSymbolType(v *symbol.SymbolType) *SymbolUpdateOne {
	if v != nil {
		_u.SetSymbolType(*v)
	}
	return _u
}

// SetScopeType sets the "scope_type" field.
func (_u *SymbolUpdateOne) SetScopeType(v symbol.ScopeType) *SymbolUpdateOne {
	_u.mutation.SetScopeType(v)
	return _u
}

// SetNillableScopeType sets the "scope_type" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableScopeType(v *symbol.ScopeType) *SymbolUpdateOne {
	if v != nil {
		_u.SetScopeType(*v)
	}
	return _u
}

// SetAccessModifier sets the "access_modifier" field.
func (_u *SymbolUpdateOne) SetAccessModifier(v symbol.AccessModifier) *SymbolUpdateOne {
	_u.mutation.SetAccessModifier(v)
	return _u
}

// SetNillableAccessModifier sets the "access_modifier" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableAccessModifier(v *symbol.AccessModifier) *SymbolUpdateOne {
	if v != nil {
		_u.SetAccessModifier(*v)
	}
	return _u
}

// ClearAccessModifier clears the value of the "access_modifier" field.
func (_u *SymbolUpdateOne) ClearAccessModifier() *SymbolUpdateOne {
	_u.mutation.ClearAccessModifier()
	return _u
}

// SetIsStatic sets the "is_static" field.
func (_u *SymbolUpdateOne) SetIsStatic(v bool) *SymbolUpdateOne {
	_u.mutation.SetIsStatic(v)
	return _u
}

// SetNillableIsStatic sets the "is_static" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableIsStatic(v *bool) *SymbolUpdateOne {
	if v != nil {
		_u.SetIsStatic(*v)
	}
	return _u
}

// SetIsAbstract sets the "is_abstract" field.
func (_u *SymbolUpdateOne) SetIsAbstract(v bool) *SymbolUpdateOne {
	_u.mutation.SetIsAbstract(v)
	return _u
}

// SetNillableIsAbstract sets the "is_abstract" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableIsAbstract(v *bool) *SymbolUpdateOne {
	if v != nil {
		_u.SetIsAbstract(*v)
	}
	return _u
}

// SetIsAsync sets the "is_async" field.
func (_u *SymbolUpdateOne) SetIsAsync(v bool) *SymbolUpdateOne {
	_u.mutation.SetIsAsync(v)
	return _u
}

// SetNillableIsAsync sets the "is_async" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableIsAsync(v *bool) *SymbolUpdateOne {
	if v != nil {
		_u.SetIsAsync(*v)
	}
	return _u
}

// SetLineNumber sets the "line_number" field.
func (_u *SymbolUpdateOne) SetLineNumber(v int) *SymbolUpdateOne {
	_u.mutation.ResetLineNumber()
	_u.mutation.SetLineNumber(v)
	return _u
}

// SetNillableLineNumber sets the "line_number" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableLineNumber(v *int) *SymbolUpdateOne {
	if v != nil {
		_u.SetLineNumber(*v)
	}
	return _u
}

// AddLineNumber adds value to the "line_number" field.
func (_u *SymbolUpdateOne) AddLineNumber(v int) *SymbolUpdateOne {
	_u.mutation.AddLineNumber(v)
	return _u
}

// SetColumnNumber sets the "column_number" field.
func (_u *SymbolUpdateOne) SetColumnNumber(v int) *SymbolUpdateOne {
	_u.mutation.ResetColumnNumber()
	_u.mutation.SetColumnNumber(v)
	return _u
}

// SetNillableColumnNumber sets the "column_number" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableColumnNumber(v *int) *SymbolUpdateOne {
	if v != nil {
		_u.SetColumnNumber(*v)
	}
	return _u
}

// AddColumnNumber adds value to the "column_number" field.
func (_u *SymbolUpdateOne) AddColumnNumber(v int) *SymbolUpdateOne {
	_u.mutation.AddColumnNumber(v)
	return _u
}

// SetMetadata sets the "metadata" field.
func (_u *SymbolUpdateOne) SetMetadata(v map[string]interface{}) *SymbolUpdateOne {
	_u.mutation.SetMetadata(v)
	return _u
}

// ClearMetadata clears the value of the "metadata" field.
func (_u *SymbolUpdateOne) ClearMetadata() *SymbolUpdateOne {
	_u.mutation.ClearMetadata()
	return _u
}

// SetCreatedAt sets the "created_at" field.
func (_u *SymbolUpdateOne) SetCreatedAt(v time.Time) *SymbolUpdateOne {
	_u.mutation.SetCreatedAt(v)
	return _u
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableCreatedAt(v *time.Time) *SymbolUpdateOne {
	if v != nil {
		_u.SetCreatedAt(*v)
	}
	return _u
}

// SetFileID sets the "file" edge to the File entity by ID.
func (_u *SymbolUpdateOne) SetFileID(id int) *SymbolUpdateOne {
	_u.mutation.SetFileID(id)
	return _u
}

// SetNillableFileID sets the "file" edge to the File entity by ID if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableFileID(id *int) *SymbolUpdateOne {
	if id != nil {
		_u = _u.SetFileID(*id)
	}
	return _u
}

// SetFile sets the "file" edge to the File entity.
func (_u *SymbolUpdateOne) SetFile(v *File) *SymbolUpdateOne {
	return _u.SetFileID(v.ID)
}

// SetAstNodeID sets the "ast_node" edge to the ASTNode entity by ID.
func (_u *SymbolUpdateOne) SetAstNodeID(id int) *SymbolUpdateOne {
	_u.mutation.SetAstNodeID(id)
	return _u
}

// SetNillableAstNodeID sets the "ast_node" edge to the ASTNode entity by ID if the given value is not nil.
func (_u *SymbolUpdateOne) SetNillableAstNodeID(id *int) *SymbolUpdateOne {
	if id != nil {
		_u = _u.SetAstNodeID(*id)
	}
	return _u
}

// SetAstNode sets the "ast_node" edge to the ASTNode entity.
func (_u *SymbolUpdateOne) SetAstNode(v *ASTNode) *SymbolUpdateOne {
	return _u.SetAstNodeID(v.ID)
}

// AddCallsMadeIDs adds the "calls_made" edge to the CallRelationship entity by IDs.
func (_u *SymbolUpdateOne) AddCallsMadeIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddCallsMadeIDs(ids...)
	return _u
}

// AddCallsMade adds the "calls_made" edges to the CallRelationship entity.
func (_u *SymbolUpdateOne) AddCallsMade(v ...*CallRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallsMadeIDs(ids...)
}

// AddCallsReceivedIDs adds the "calls_received" edge to the CallRelationship entity by IDs.
func (_u *SymbolUpdateOne) AddCallsReceivedIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddCallsReceivedIDs(ids...)
	return _u
}

// AddCallsReceived adds the "calls_received" edges to the CallRelationship entity.
func (_u *SymbolUpdateOne) AddCallsReceived(v ...*CallRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCallsReceivedIDs(ids...)
}

// AddReferenceIDs adds the "references" edge to the SymbolReference entity by IDs.
func (_u *SymbolUpdateOne) AddReferenceIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddReferenceIDs(ids...)
	return _u
}

// AddReferences adds the "references" edges to the SymbolReference entity.
func (_u *SymbolUpdateOne) AddReferences(v ...*SymbolReference) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddReferenceIDs(ids...)
}

// AddChildClassIDs adds the "child_classes" edge to the InheritanceRelationship entity by IDs.
func (_u *SymbolUpdateOne) AddChildClassIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddChildClassIDs(ids...)
	return _u
}

// AddChildClasses adds the "child_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdateOne) AddChildClasses(v ...*InheritanceRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddChildClassIDs(ids...)
}

// AddParentClassIDs adds the "parent_classes" edge to the InheritanceRelationship entity by IDs.
func (_u *SymbolUpdateOne) AddParentClassIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddParentClassIDs(ids...)
	return _u
}

// AddParentClasses adds the "parent_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdateOne) AddParentClasses(v ...*InheritanceRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddParentClassIDs(ids...)
}

// AddImportReferenceIDs adds the "import_references" edge to the ImportStatement entity by IDs.
func (_u *SymbolUpdateOne) AddImportReferenceIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.AddImportReferenceIDs(ids...)
	return _u
}

// AddImportReferences adds the "import_references" edges to the ImportStatement entity.
func (_u *SymbolUpdateOne) AddImportReferences(v ...*ImportStatement) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddImportReferenceIDs(ids...)
}

// Mutation returns the SymbolMutation object of the builder.
func (_u *SymbolUpdateOne) Mutation() *SymbolMutation {
	return _u.mutation
}

// ClearFile clears the "file" edge to the File entity.
func (_u *SymbolUpdateOne) ClearFile() *SymbolUpdateOne {
	_u.mutation.ClearFile()
	return _u
}

// ClearAstNode clears the "ast_node" edge to the ASTNode entity.
func (_u *SymbolUpdateOne) ClearAstNode() *SymbolUpdateOne {
	_u.mutation.ClearAstNode()
	return _u
}

// ClearCallsMade clears all "calls_made" edges to the CallRelationship entity.
func (_u *SymbolUpdateOne) ClearCallsMade() *SymbolUpdateOne {
	_u.mutation.ClearCallsMade()
	return _u
}

// RemoveCallsMadeIDs removes the "calls_made" edge to CallRelationship entities by IDs.
func (_u *SymbolUpdateOne) RemoveCallsMadeIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveCallsMadeIDs(ids...)
	return _u
}

// RemoveCallsMade removes "calls_made" edges to CallRelationship entities.
func (_u *SymbolUpdateOne) RemoveCallsMade(v ...*CallRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallsMadeIDs(ids...)
}

// ClearCallsReceived clears all "calls_received" edges to the CallRelationship entity.
func (_u *SymbolUpdateOne) ClearCallsReceived() *SymbolUpdateOne {
	_u.mutation.ClearCallsReceived()
	return _u
}

// RemoveCallsReceivedIDs removes the "calls_received" edge to CallRelationship entities by IDs.
func (_u *SymbolUpdateOne) RemoveCallsReceivedIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveCallsReceivedIDs(ids...)
	return _u
}

// RemoveCallsReceived removes "calls_received" edges to CallRelationship entities.
func (_u *SymbolUpdateOne) RemoveCallsReceived(v ...*CallRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCallsReceivedIDs(ids...)
}

// ClearReferences clears all "references" edges to the SymbolReference entity.
func (_u *SymbolUpdateOne) ClearReferences() *SymbolUpdateOne {
	_u.mutation.ClearReferences()
	return _u
}

// RemoveReferenceIDs removes the "references" edge to SymbolReference entities by IDs.
func (_u *SymbolUpdateOne) RemoveReferenceIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveReferenceIDs(ids...)
	return _u
}

// RemoveReferences removes "references" edges to SymbolReference entities.
func (_u *SymbolUpdateOne) RemoveReferences(v ...*SymbolReference) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveReferenceIDs(ids...)
}

// ClearChildClasses clears all "child_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdateOne) ClearChildClasses() *SymbolUpdateOne {
	_u.mutation.ClearChildClasses()
	return _u
}

// RemoveChildClassIDs removes the "child_classes" edge to InheritanceRelationship entities by IDs.
func (_u *SymbolUpdateOne) RemoveChildClassIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveChildClassIDs(ids...)
	return _u
}

// RemoveChildClasses removes "child_classes" edges to InheritanceRelationship entities.
func (_u *SymbolUpdateOne) RemoveChildClasses(v ...*InheritanceRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveChildClassIDs(ids...)
}

// ClearParentClasses clears all "parent_classes" edges to the InheritanceRelationship entity.
func (_u *SymbolUpdateOne) ClearParentClasses() *SymbolUpdateOne {
	_u.mutation.ClearParentClasses()
	return _u
}

// RemoveParentClassIDs removes the "parent_classes" edge to InheritanceRelationship entities by IDs.
func (_u *SymbolUpdateOne) RemoveParentClassIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveParentClassIDs(ids...)
	return _u
}

// RemoveParentClasses removes "parent_classes" edges to InheritanceRelationship entities.
func (_u *SymbolUpdateOne) RemoveParentClasses(v ...*InheritanceRelationship) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveParentClassIDs(ids...)
}

// ClearImportReferences clears all "import_references" edges to the ImportStatement entity.
func (_u *SymbolUpdateOne) ClearImportReferences() *SymbolUpdateOne {
	_u.mutation.ClearImportReferences()
	return _u
}

// RemoveImportReferenceIDs removes the "import_references" edge to ImportStatement entities by IDs.
func (_u *SymbolUpdateOne) RemoveImportReferenceIDs(ids ...int) *SymbolUpdateOne {
	_u.mutation.RemoveImportReferenceIDs(ids...)
	return _u
}

// RemoveImportReferences removes "import_references" edges to ImportStatement entities.
func (_u *SymbolUpdateOne) RemoveImportReferences(v ...*ImportStatement) *SymbolUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveImportReferenceIDs(ids...)
}

// Where appends a list predicates to the SymbolUpdate builder.
func (_u *SymbolUpdateOne) Where(ps ...predicate.Symbol) *SymbolUpdateOne {
	_u.mutation.Where(ps...)
	return _u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *SymbolUpdateOne) Select(field string, fields ...string) *SymbolUpdateOne {
	_u.fields = append([]string{field}, fields...)
	return _u
}

// Save executes the query and returns the updated Symbol entity.
func (_u *SymbolUpdateOne) Save(ctx context.Context) (*Symbol, error) {
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *SymbolUpdateOne) SaveX(ctx context.Context) *Symbol {
	node, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (_u *SymbolUpdateOne) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *SymbolUpdateOne) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *SymbolUpdateOne) check() error {
	if v, ok := _u.mutation.Name(); ok {
		if err := symbol.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Symbol.name": %w`, err)}
		}
	}
	if v, ok := _u.mutation.QualifiedName(); ok {
		if err := symbol.QualifiedNameValidator(v); err != nil {
			return &ValidationError{Name: "qualified_name", err: fmt.Errorf(`ent: validator failed for field "Symbol.qualified_name": %w`, err)}
		}
	}
	if v, ok := _u.mutation.SymbolType(); ok {
		if err := symbol.SymbolTypeValidator(v); err != nil {
			return &ValidationError{Name: "symbol_type", err: fmt.Errorf(`ent: validator failed for field "Symbol.symbol_type": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ScopeType(); ok {
		if err := symbol.ScopeTypeValidator(v); err != nil {
			return &ValidationError{Name: "scope_type", err: fmt.Errorf(`ent: validator failed for field "Symbol.scope_type": %w`, err)}
		}
	}
	if v, ok := _u.mutation.AccessModifier(); ok {
		if err := symbol.AccessModifierValidator(v); err != nil {
			return &ValidationError{Name: "access_modifier", err: fmt.Errorf(`ent: validator failed for field "Symbol.access_modifier": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LineNumber(); ok {
		if err := symbol.LineNumberValidator(v); err != nil {
			return &ValidationError{Name: "line_number", err: fmt.Errorf(`ent: validator failed for field "Symbol.line_number": %w`, err)}
		}
	}
	if v, ok := _u.mutation.ColumnNumber(); ok {
		if err := symbol.ColumnNumberValidator(v); err != nil {
			return &ValidationError{Name: "column_number", err: fmt.Errorf(`ent: validator failed for field "Symbol.column_number": %w`, err)}
		}
	}
	return nil
}

func (_u *SymbolUpdateOne) sqlSave(ctx context.Context) (_node *Symbol, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(symbol.Table, symbol.Columns, sqlgraph.NewFieldSpec(symbol.FieldID, field.TypeInt))
	id, ok := _u.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Symbol.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := _u.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, symbol.FieldID)
		for _, f := range fields {
			if !symbol.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != symbol.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.Name(); ok {
		_spec.SetField(symbol.FieldName, field.TypeString, value)
	}
	if value, ok := _u.mutation.QualifiedName(); ok {
		_spec.SetField(symbol.FieldQualifiedName, field.TypeString, value)
	}
	if value, ok := _u.mutation.SymbolType(); ok {
		_spec.SetField(symbol.FieldSymbolType, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.ScopeType(); ok {
		_spec.SetField(symbol.FieldScopeType, field.TypeEnum, value)
	}
	if value, ok := _u.mutation.AccessModifier(); ok {
		_spec.SetField(symbol.FieldAccessModifier, field.TypeEnum, value)
	}
	if _u.mutation.AccessModifierCleared() {
		_spec.ClearField(symbol.FieldAccessModifier, field.TypeEnum)
	}
	if value, ok := _u.mutation.IsStatic(); ok {
		_spec.SetField(symbol.FieldIsStatic, field.TypeBool, value)
	}
	if value, ok := _u.mutation.IsAbstract(); ok {
		_spec.SetField(symbol.FieldIsAbstract, field.TypeBool, value)
	}
	if value, ok := _u.mutation.IsAsync(); ok {
		_spec.SetField(symbol.FieldIsAsync, field.TypeBool, value)
	}
	if value, ok := _u.mutation.LineNumber(); ok {
		_spec.SetField(symbol.FieldLineNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedLineNumber(); ok {
		_spec.AddField(symbol.FieldLineNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.ColumnNumber(); ok {
		_spec.SetField(symbol.FieldColumnNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedColumnNumber(); ok {
		_spec.AddField(symbol.FieldColumnNumber, field.TypeInt, value)
	}
	if value, ok := _u.mutation.Metadata(); ok {
		_spec.SetField(symbol.FieldMetadata, field.TypeJSON, value)
	}
	if _u.mutation.MetadataCleared() {
		_spec.ClearField(symbol.FieldMetadata, field.TypeJSON)
	}
	if value, ok := _u.mutation.CreatedAt(); ok {
		_spec.SetField(symbol.FieldCreatedAt, field.TypeTime, value)
	}
	if _u.mutation.FileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   symbol.FileTable,
			Columns: []string{symbol.FileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.FileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   symbol.FileTable,
			Columns: []string{symbol.FileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.AstNodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   symbol.AstNodeTable,
			Columns: []string{symbol.AstNodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.AstNodeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   symbol.AstNodeTable,
			Columns: []string{symbol.AstNodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(astnode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallsMadeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallsMadeIDs(); len(nodes) > 0 && !_u.mutation.CallsMadeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallsMadeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsMadeTable,
			Columns: []string{symbol.CallsMadeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CallsReceivedCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCallsReceivedIDs(); len(nodes) > 0 && !_u.mutation.CallsReceivedCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CallsReceivedIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.CallsReceivedTable,
			Columns: []string{symbol.CallsReceivedColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(callrelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedReferencesIDs(); len(nodes) > 0 && !_u.mutation.ReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ReferencesTable,
			Columns: []string{symbol.ReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(symbolreference.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ChildClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedChildClassesIDs(); len(nodes) > 0 && !_u.mutation.ChildClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ChildClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ChildClassesTable,
			Columns: []string{symbol.ChildClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ParentClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedParentClassesIDs(); len(nodes) > 0 && !_u.mutation.ParentClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ParentClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ParentClassesTable,
			Columns: []string{symbol.ParentClassesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inheritancerelationship.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ImportReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedImportReferencesIDs(); len(nodes) > 0 && !_u.mutation.ImportReferencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ImportReferencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   symbol.ImportReferencesTable,
			Columns: []string{symbol.ImportReferencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(importstatement.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Symbol{config: _u.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{symbol.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	_u.mutation.done = true
	return _node, nil
}
