
django:
  django.conf.settings:
    - requests.post(\n                    url=req_url,\n                    auth=HTTPBasicAuth(jira_instance.username, jira_instance.password),\n                    json=json_data,\n                    timeout=settings.REQUESTS_TIMEOUT,\n                )
    - requests.get(\n                    "https://raw.githubusercontent.com/ozh/github-colors/master/colors.json",\n                    timeout=settings.REQUESTS_TIMEOUT,\n                )
    - "{};{}/finding/{};{};{};{};{};{};{};{};{};{};{};{};unable to retrieve JIRA Issue;{}".format(\n                find.jira_issue.jira_key, settings.SITE_URL, find.id, find.status(), None, None, None, Non...
    - "{}; {}/finding/{};{};{};{};{};{};{};{};{};{};{};{};skipping finding with no last_status_update;{}".format(\n                find.jira_issue.jira_key, settings.SITE_URL, find.id, find.status(), None, ...
    - "{}; {}/finding/{};{};{};{};{};{};{};{};{};{};{};{}skipping risk accepted findings;{}".format(\n                find.jira_issue.jira_key, settings.SITE_URL, find.id, find.status(), resolution_name, No...
    - "{}; {}/finding/{};{};{};{};{};{};{};{};{};{};{};{};no action both sides are active/open;{}".format(\n                find.jira_issue.jira_key, settings.SITE_URL, find.id, find.status(), resolution_na...
    - "{}; {}/finding/{};{};{};{};{};{};{};{};{};{};{};{};no action both sides are inactive/closed;{}".format(\n                find.jira_issue.jira_key, settings.SITE_URL, find.id, find.status(), resolutio...
    - message = f"{find.jira_issue.jira_key}; {settings.SITE_URL}/finding/{find.id};{find.status()};{resolution_name};{flag1};{flag2};{flag3};{find.jira_issue.jira_change};{issue_from_jira.fields.updated};{...
    - message = f"{find.jira_issue.jira_key}; {settings.SITE_URL}/finding/{find.id};{find.status()};{resolution_name};{flag1};{flag2};{flag3};{find.jira_issue.jira_change};{issue_from_jira.fields.updated};{...
    - message = f"{find.jira_issue.jira_key}; {settings.SITE_URL}/finding/{find.id};{find.status()};{resolution_name};{flag1};{flag2};{flag3};{message_action};{find.jira_issue.jira_change};{issue_from_jira....
    - message = f"{find.jira_issue.jira_key}; {settings.SITE_URL}/finding/{find.id};{find.status()};{resolution_name};{flag1};{flag2};{flag3};{find.jira_issue.jira_change};{issue_from_jira.fields.updated};{...
    - message = f"{find.jira_issue.jira_key}; {settings.SITE_URL}/finding/{find.id};{find.status()};{resolution_name};{flag1};{flag2};{flag3};{find.jira_issue.jira_change};{issue_from_jira.fields.updated};{...
    - dir(settings)
    - getattr(settings, attr)
    - settings.LOGIN_URL.lstrip("/")
    - hasattr(settings, "LOGIN_EXEMPT_URLS")
    - EXEMPT_URLS += [re.compile(expr) for expr in settings.LOGIN_EXEMPT_URLS]
    - fullURL = f"{settings.LOGIN_URL}?next=/"
    - fullURL = f"{settings.LOGIN_URL}?next={quote(request.get_full_path())}"
    - request.META.update(settings.ADDITIONAL_HEADERS)
    - valid_extensions = settings.FILE_UPLOAD_TYPES
    - deduplicationAlgorithm = settings.DEDUPE_ALGO_LEGACY
    - hasattr(settings, "DEDUPLICATION_ALGORITHM_PER_PARSER")
    - if (self.test_type.name in settings.DEDUPLICATION_ALGORITHM_PER_PARSER):\n                deduplicationLogger.debug(f"using DEDUPLICATION_ALGORITHM_PER_PARSER for test_type.name: {self.test_type.name}...
    - deduplicationAlgorithm = settings.DEDUPLICATION_ALGORITHM_PER_PARSER[self.test_type.name]
    - if (self.test_type.name in settings.DEDUPLICATION_ALGORITHM_PER_PARSER):\n                deduplicationLogger.debug(f"using DEDUPLICATION_ALGORITHM_PER_PARSER for test_type.name: {self.test_type.name}...
    - deduplicationAlgorithm = settings.DEDUPLICATION_ALGORITHM_PER_PARSER[self.scan_type]
    - hasattr(settings, "HASHCODE_FIELDS_PER_SCANNER")
    - if (self.test_type.name in settings.HASHCODE_FIELDS_PER_SCANNER):\n                deduplicationLogger.debug(f"using HASHCODE_FIELDS_PER_SCANNER for test_type.name: {self.test_type.name}")\n          ...
    - hashCodeFields = settings.HASHCODE_FIELDS_PER_SCANNER[self.test_type.name]
    - if (self.test_type.name in settings.HASHCODE_FIELDS_PER_SCANNER):\n                deduplicationLogger.debug(f"using HASHCODE_FIELDS_PER_SCANNER for test_type.name: {self.test_type.name}")\n          ...
    - hashCodeFields = settings.HASHCODE_FIELDS_PER_SCANNER[self.scan_type]
    - hasattr(settings, "HASHCODE_ALLOWS_NULL_CWE")
    - if (self.test_type.name in settings.HASHCODE_ALLOWS_NULL_CWE):\n                deduplicationLogger.debug(f"using HASHCODE_ALLOWS_NULL_CWE for test_type.name: {self.test_type.name}")\n                ...
    - hashCodeAllowsNullCwe = settings.HASHCODE_ALLOWS_NULL_CWE[self.test_type.name]
    - if (self.test_type.name in settings.HASHCODE_ALLOWS_NULL_CWE):\n                deduplicationLogger.debug(f"using HASHCODE_ALLOWS_NULL_CWE for test_type.name: {self.test_type.name}")\n                ...
    - hashCodeAllowsNullCwe = settings.HASHCODE_ALLOWS_NULL_CWE[self.scan_type]
    - hasattr(settings, "HASHCODE_FIELDS_PER_SCANNER")
    - hasattr(settings, "HASHCODE_ALLOWS_NULL_CWE")
    - hasattr(settings, "HASHCODE_ALLOWED_FIELDS")
    - all(elem in settings.HASHCODE_ALLOWED_FIELDS for elem in hash_code_fields)
    - hasattr(settings, "HASH_CODE_FIELDS_ALWAYS")
    - for field in settings.HASH_CODE_FIELDS_ALWAYS:\n                if getattr(self, field):\n                    fields_to_hash += str(getattr(self, field))
    - from dateutil.parser import parse\n        if start_date and isinstance(start_date, str):\n            start_date = parse(start_date).date()\n\n        from dojo.utils import get_work_days\n        if...
    - hasattr(settings, "JIRA_ISSUE_TYPE_CHOICES_CONFIG")
    - default_issue_type_choices = settings.JIRA_ISSUE_TYPE_CHOICES_CONFIG
    - import base64\nimport copy\nimport hashlib\nimport logging\nimport re\nimport warnings\nfrom contextlib import suppress\nfrom datetime import datetime\nfrom pathlib import Path\nfrom uuid import uuid4...
    - getattr(\n                settings,\n                "NOTIFICATION_MANAGER",\n                default_manager,\n            )
    - requests.request(\n            method="POST",\n            url="https://slack.com/api/users.lookupByEmail",\n            data={"token": self.system_settings.slack_token, "email": user_email},\n            timeout=settings.REQUESTS_TIMEOUT,\n        )
    - requests.request(\n            method="POST",\n            url="https://slack.com/api/chat.postMessage",\n            data={\n                "token": self.system_settings.slack_token,\n              ...
    - requests.request(\n                        method="POST",\n                        url=self.system_settings.msteams_url,\n                        data=self._create_notification_message(\n             ...
    - headers = {\n            "User-Agent": f"DefectDojo-{dd_version}",\n            "X-DefectDojo-Event": event,\n            "X-DefectDojo-Instance": settings.SITE_URL,\n            "Accept": "application/json",\n        }
    - if event in settings.NOTIFICATIONS_SYSTEM_LEVEL_TRUMP:\n                # merge the system level notifications with the personal level\n                # this allows for system to trump the personal\n...
    - if settings.AZUREAD_TENANT_OAUTH2_ENABLED and isinstance(backend, AzureADTenantOAuth2):\n        """Return user details from Azure AD account"""\n        fullname, first_name, last_name, upn = (\n    ...
    - if settings.AZUREAD_TENANT_OAUTH2_ENABLED and isinstance(backend, AzureADTenantOAuth2):\n        """Return user details from Azure AD account"""\n        fullname, first_name, last_name, upn = (\n    ...
    - if settings.AZUREAD_TENANT_OAUTH2_ENABLED and settings.AZUREAD_TENANT_OAUTH2_GET_GROUPS and isinstance(backend, AzureADTenantOAuth2):\n        # In some wild cases, there could be two social auth user...
    - if settings.AZUREAD_TENANT_OAUTH2_ENABLED and settings.AZUREAD_TENANT_OAUTH2_GET_GROUPS and isinstance(backend, AzureADTenantOAuth2):\n        # In some wild cases, there could be two social auth user...
    - requests.get(\n                        (str(soc.extra_data["resource"]) + "/v1.0/groups/" + str(group_from_response) + "?$select=displayName"),\n                        headers=request_headers,\n                        timeout=settings.REQUESTS_TIMEOUT,\n                    )
    - logger.debug("Analysing Group_ID " + group_from_response)\n                request_headers = {"Authorization": "Bearer " + token}\n                if is_group_id(group_from_response):\n               ...
    - re.search(settings.AZUREAD_TENANT_OAUTH2_GROUPS_FILTER, group_name)
    - logger.debug("Skipping group " + group_name + " due to AZUREAD_TENANT_OAUTH2_GROUPS_FILTER " + settings.AZUREAD_TENANT_OAUTH2_GROUPS_FILTER)
    - soc = user.social_auth.order_by("-created").first()\n        token = soc.extra_data["access_token"]\n        group_names = []\n        if "groups" not in kwargs["response"] or kwargs["response"]["grou...
    - if settings.GITLAB_PROJECT_AUTO_IMPORT is True:\n        # Get user's product names\n        user_product_names = [prod.name for prod in get_authorized_products(Permissions.Product_View, user)]\n     ...
    - gitlab.Gitlab(settings.SOCIAL_AUTH_GITLAB_API_URL, oauth_token=token)
    - gl.projects.list(membership=True, min_access_level=settings.GITLAB_PROJECT_MIN_ACCESS_LEVEL, all=True)
    - try:\n                    # Check if there is a product with the name of the GitLab project\n                    product = Product.objects.get(name=project.path_with_namespace)\n                except...
    - try:\n                    # Check if there is a product with the name of the GitLab project\n                    product = Product.objects.get(name=project.path_with_namespace)\n                except...
    - try:\n                    # Check if there is a product with the name of the GitLab project\n                    product = Product.objects.get(name=project.path_with_namespace)\n                except...
    - try:\n                    # Check if there is a product with the name of the GitLab project\n                    product = Product.objects.get(name=project.path_with_namespace)\n                except...
    - if not settings.SOCIAL_AUTH_CREATE_USER:\n        return None\n    details["username"] = sanitize_username(details.get("username"))\n    return social_core.pipeline.user.create_user(strategy, details, backend, user, args, kwargs)
    - if settings.ENABLE_AUDITLOG:\n        le = LogEntry.objects.get(\n            action=LogEntry.Action.DELETE,\n            content_type=ContentType.objects.get(app_label="dojo", model="product"),\n    ...
    - if settings.ENABLE_AUDITLOG:\n        le = LogEntry.objects.get(\n            action=LogEntry.Action.DELETE,\n            content_type=ContentType.objects.get(app_label="dojo", model="product_type"),\...
    - if IPAddress(request.META["REMOTE_ADDR"]) in settings.AUTH_REMOTEUSER_TRUSTED_PROXY:\n            self.header = settings.AUTH_REMOTEUSER_USERNAME_HEADER\n            if self.header in request.META:\n ...
    - self.header = settings.AUTH_REMOTEUSER_USERNAME_HEADER
    - logger.debug("Requested came from untrusted proxy %s; This is list of trusted proxies: %s",\n            IPAddress(request.META["REMOTE_ADDR"]),\n            settings.AUTH_REMOTEUSER_TRUSTED_PROXY)
    - if not settings.AUTH_REMOTEUSER_ENABLED:\n            return None\n\n        # process only if request is comming from the trusted proxy node\n        if IPAddress(request.META["REMOTE_ADDR"]) in sett...
    - if not settings.AUTH_REMOTEUSER_ENABLED:\n            return None\n\n        # process only if request is comming from the trusted proxy node\n        if IPAddress(request.META["REMOTE_ADDR"]) in sett...
    - self.header = settings.AUTH_REMOTEUSER_USERNAME_HEADER
    - logger.debug("Requested came from untrusted proxy %s; This is list of trusted proxies: %s",\n            IPAddress(request.META["REMOTE_ADDR"]),\n            settings.AUTH_REMOTEUSER_TRUSTED_PROXY)
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - user.email = request.META[settings.AUTH_REMOTEUSER_EMAIL_HEADER]
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - user.first_name = request.META[settings.AUTH_REMOTEUSER_FIRSTNAME_HEADER]
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - user.last_name = request.META[settings.AUTH_REMOTEUSER_LASTNAME_HEADER]
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - request.META[settings.AUTH_REMOTEUSER_GROUPS_HEADER].split(",")
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - changed = False\n\n        if settings.AUTH_REMOTEUSER_EMAIL_HEADER and \\n          settings.AUTH_REMOTEUSER_EMAIL_HEADER in request.META and \\n          user.email != request.META[settings.AUTH_REM...
    - request.META[settings.AUTH_REMOTEUSER_GROUPS_HEADER].split(",")
    - if not settings.AUTH_REMOTEUSER_VISIBLE_IN_SWAGGER:\n            return {}\n\n        header_name = settings.AUTH_REMOTEUSER_USERNAME_HEADER\n        header_name = header_name.removeprefix("HTTP_")\n ...
    - header_name = settings.AUTH_REMOTEUSER_USERNAME_HEADER
    - context = {"product_type": product_type,\n                   "products": products,\n                   "engagements": engagements,\n                   "tests": tests,\n                   "report_name"...
    - context = {"product": product,\n                   "engagements": engagements,\n                   "tests": tests,\n                   "report_name": report_name,\n                   "findings": findi...
    - context = {"engagement": engagement,\n                   "tests": tests,\n                   "report_name": report_name,\n                   "findings": findings.qs.distinct().order_by("numerical_seve...
    - context = {"test": test,\n                   "report_name": report_name,\n                   "findings": findings.qs.distinct().order_by("numerical_severity"),\n                   "include_finding_not...
    - context = {"findings": findings.qs.distinct().order_by("numerical_severity"),\n                   "report_name": report_name,\n                   "include_finding_notes": include_finding_notes,\n     ...
    - render(request,\n                          template,\n                          {"product_type": product_type,\n                           "product": product,\n                           "engagement":...
    - render(request, self.get_template(), {\n                        "report_name": "Finding Report",\n                        "product": product,\n                        "engagement": engagement,\n      ...
    - max_results = settings.SEARCH_MAX_RESULTS
    - hasattr(settings, "CELERY_RESULT_BACKEND")
    - max_alerts_per_user = settings.MAX_ALERTS_PER_USER
    - retention_period = settings.AUDITLOG_FLUSH_RETENTION_PERIOD
    - total_duplicate_delete_count_max_per_run = settings.DUPE_DELETE_MAX_PER_RUN
    - if not settings.CREATE_CLOUD_BANNER:\n        return\n    # Get the announcement object\n    announcement = Announcement.objects.get_or_create(id=1)[0]\n    # Quick check for a user has modified the c...
    - from dojo import __version__\n    version = __version__\n    if settings.FOOTER_VERSION:\n        version = settings.FOOTER_VERSION\n    return f"v. {version}"
    - version = settings.FOOTER_VERSION
    - getattr(settings, name, False)
    - any(vulnerability_id.upper().startswith(key) for key in settings.VULNERABILITY_URLS)
    - if not vulnerability_id:\n        return False\n\n    for key in settings.VULNERABILITY_URLS:\n        if vulnerability_id.upper().startswith(key):\n            if key == "GLSA":\n                retu...
    - return settings.VULNERABILITY_URLS[key] + str(vulnerability_id.replace("GLSA-", "glsa/"))
    - return settings.VULNERABILITY_URLS[key] + str(vulnerability_id.lower())
    - if key == "GLSA":\n                return settings.VULNERABILITY_URLS[key] + str(vulnerability_id.replace("GLSA-", "glsa/"))\n            if key in ["AVD", "KHV", "C-"]:\n                return settin...
    - settings.VULNERABILITY_URLS[key].split("&&")
    - settings.VULNERABILITY_URLS[key].split("&&")
    - return settings.VULNERABILITY_URLS[key] + str(vulnerability_id)
    - if not finding or not settings.TRACK_IMPORT_HISTORY:\n        return ""\n\n    if autoescape:\n        conditional_escape\n    else:\n        lambda x: x\n\n    # prefetched, so no filtering here\n   ...
    - hasattr(settings, config_setting)
    - getattr(settings, config_setting, None)
    - if settings.ENABLE_AUDITLOG:\n            le = LogEntry.objects.get(\n                action=LogEntry.Action.DELETE,\n                content_type=ContentType.objects.get(app_label="dojo", model="test...
    - self.session.get(\n                url=next,\n                timeout=settings.REQUESTS_TIMEOUT,\n            )
    - self.session.get(\n            url=f"{self.bugcrowd_api_url}/programs",\n            timeout=settings.REQUESTS_TIMEOUT,\n        )
    - self.session.get(\n            url=f"{self.bugcrowd_api_url}/submissions",\n            timeout=settings.REQUESTS_TIMEOUT,\n        )
    - self.session.get(\n                url=f"{self.bugcrowd_api_url}/targets",\n                timeout=settings.REQUESTS_TIMEOUT,\n            )
    - self.session.get(\n            url=f"{self.cobalt_api_url}/assets?limit=1000",\n            headers=self.get_headers(),\n            timeout=settings.REQUESTS_TIMEOUT,\n        )
