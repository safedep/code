
subprocess:
  subprocess:
    - subprocess.run(cmd, cwd=cwd, env=env, capture_output=True, text=True, check=False)

celery:
  celery.Celery:
    - Celery("dojo")
  celery.signals.setup_logging:
    - import logging\nimport os\n\nfrom celery import Celery\nfrom celery.signals import setup_logging\nfrom django.conf import settings\n\nlogger = logging.getLogger(__name__)\n\n# set the default Django s...
  celery.schedules.crontab:
    - crontab(hour=7, minute=30)
    - crontab(minute=0, hour="*/3")
  celery.utils.log.get_task_logger:
    - get_task_logger(__name__)

markdown:
  markdown:
    - markdown.markdown(value,\n                                          extensions=["markdown.extensions.nl2br",\n                                                      "markdown.extensions.sane_lists",\n ...
    - markdown.markdown(value,\n                                          extensions=["markdown.extensions.nl2br",\n                                                      "markdown.extensions.sane_lists",\n ...

html2text:
  html2text:
    - html2text.HTML2Text()
    - html2text.html2text(\n                        item.findtext("Description"),\n                    )
    - html2text.html2text(\n                        item.findtext("Description"),\n                    )
    - html2text.html2text(item.findtext("Details"))
    - html2text.html2text(item.findtext("Details"))
    - html2text.html2text(item.findtext("Details"))
    - html2text.html2text(item.findtext("Details"))
    - html2text.HTML2Text()
    - html2text.html2text(description)
    - html2text.html2text(description)
    - html2text.html2text(mitigation)
    - html2text.html2text(mitigation)
    - html2text.html2text(description)
    - html2text.html2text(description)
    - html2text.html2text(remediation)
    - html2text.html2text(remediation)
    - html2text.html2text(references)
    - html2text.html2text(references)
    - html2text.HTML2Text()
    - html2text.html2text(issue.get("description_html"))
    - html2text.html2text(issue.get("description_html"))
    - html2text.html2text(\n                issue.get("description_html"),\n            )
    - html2text.html2text(\n                issue.get("description_html"),\n            )
    - html2text.html2text(\n                    issue["issue_type"].get("description_html"),\n                )
    - html2text.html2text(\n                    issue["issue_type"].get("description_html"),\n                )
    - html2text.html2text(\n                issue["issue_type"].get("description_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("description_html"),\n            )
    - html2text.html2text(\n                    issue["issue_type"].get("remediation_html"),\n                )
    - html2text.html2text(\n                    issue["issue_type"].get("remediation_html"),\n                )
    - html2text.html2text(\n                issue["issue_type"].get("remediation_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("remediation_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("references_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("references_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("vulnerability_classifications_html"),\n            )
    - html2text.html2text(\n                issue["issue_type"].get("vulnerability_classifications_html"),\n            )
    - html2text.html2text(\n                            data.get("data_html"),\n                        )
    - html2text.html2text(\n                            data.get("data_html"),\n                        )
    - html2text.html2text(\n                            data.get("highlight_html"),\n                        )
    - html2text.html2text(\n                            data.get("highlight_html"),\n                        )
    - html2text.html2text(\n                            data.get("data_html"),\n                        )
    - html2text.html2text(\n                            data.get("data_html"),\n                        )
    - html2text.html2text(\n                            data.get("highlight_html"),\n                        )
    - html2text.html2text(\n                            data.get("highlight_html"),\n                        )
    - html2text.html2text(\n                                content.find("SectionText").text,\n                            )
    - html2text.html2text(\n                                content.find("SectionText").text,\n                            )
    - html2text(test_description)
    - html2text(mobsf_finding["description"])
    - html2text.html2text(item.get("Description", ""))
    - html2text.html2text(item.get("Description", ""))
    - html2text.html2text(item.get("RemedialProcedure", ""))
    - html2text.html2text(item.get("RemedialProcedure", ""))
    - html2text.html2text(item.get("RemedyReferences", ""))
    - html2text.html2text(item.get("RemedyReferences", ""))
    - html2text.html2text(item.get("Impact", ""))
    - html2text.html2text(item.get("Impact", ""))
    - html2text.html2text(vuln.get("pluginOutput", ""))
    - html2text.html2text(vuln.get("pluginOutput", ""))
    - html2text.html2text(vuln["desc"].strip())
    - html2text.html2text(vuln["desc"].strip())
    - html2text.html2text(vuln.get("pluginOutput", "").strip())
    - html2text.html2text(vuln.get("pluginOutput", "").strip())
    - html2text.html2text(vuln.get("resolution"))
    - html2text.html2text(vuln.get("resolution"))
    - html2text.HTML2Text()
    - html2text.HTML2Text()
    - html2text(issue_sections.get("References", ""))
    - html2text.HTML2Text()
    - html2text(item.findtext("desc"))
    - html2text(item.findtext("solution"))
    - html2text(item.findtext("reference"))

group_test:
  group_test.GroupTest:
    - GroupTest("test_create_group")
    - GroupTest("test_group_edit_name_and_global_role")
    - GroupTest("test_group_delete")
    - GroupTest("test_create_group")
    - GroupTest("test_group_edit_name_and_global_role")
    - GroupTest("test_group_delete")

datetime:
  datetime.timedelta:
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=7)
    - timedelta(days=1)
    - timedelta(days=30)
    - timedelta(days=1)
    - timedelta(days=90)
    - timedelta(days=1)
    - timedelta(days=365)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=7)
    - timedelta(days=1)
    - timedelta(days=30)
    - timedelta(days=1)
    - timedelta(days=90)
    - timedelta(days=7)
    - timedelta(days=1)
    - timedelta(days=30)
    - timedelta(days=1)
    - timedelta(days=90)
    - timedelta(days=1)
    - timedelta(days=365)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=365)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=days)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=1)
    - timedelta(days=7)
    - timedelta(days=365)
    - timedelta(days=-start_date.weekday())
    - timedelta(days=30)
    - timedelta(days=60)
    - timedelta(days=90)
    - timedelta(hours=24)
    - timedelta(minutes=5)
    - timedelta(days=jan4.isoweekday() - 1)
    - timedelta(weeks=iso_week - 1, days=iso_day - 1)
    - timedelta(days=7)
    - timedelta(days=7)
    - timedelta(days=recent_test_day_count)
    - timedelta(days=7)
    - timedelta(hours=1)
    - timedelta(hours=1)
    - timedelta(hours=8)
    - timedelta(minutes=1)
    - timedelta(minutes=1)
    - timedelta(hours=8)
    - timedelta(hours=3)
    - timedelta(minutes=1)
    - timedelta(hours=8)
    - timedelta(days=7)
    - timedelta(days=3)
    - timedelta(days=3)
    - timedelta(days=close_days)
    - timedelta(seconds=settings.PASSWORD_RESET_TIMEOUT)
    - timedelta(days=7 - start.weekday())
    - timedelta(days=end.weekday() - WEEKDAY_FRIDAY)
    - timedelta(days=90)
    - timedelta(days=i)
    - timedelta(days=1)
  datetime.date:
    - date.today()
    - date = self.cleaned_data.get("scan_date", None)
    - date = self.cleaned_data.get("scan_date", None)\n        if date and date.date() > datetime.today().date():\n            msg = "The date cannot be in the future!"\n            raise forms.ValidationError(msg)\n        return date
    - date.date()
    - date.date()
    - datetime.today().date()
    - return date
    - date = self.cleaned_data.get("scan_date", None)
    - date = self.cleaned_data.get("scan_date", None)\n        if date and date.date() > timezone.localtime(timezone.now()).date():\n            msg = "The date cannot be in the future!"\n            raise forms.ValidationError(msg)\n        return date
    - date.date()
    - date.date()
    - timezone.localtime(timezone.now()).date()
    - return date
    - timezone.now().date()
    - date = forms.DateField(required=True,\n                           widget=forms.TextInput(attrs={"class": "datepicker", "autocomplete": "off"}))
    - date = forms.DateField(required=True,\n                           widget=forms.TextInput(attrs={"class": "datepicker", "autocomplete": "off"}))
    - date = forms.DateField(required=True,\n                           widget=forms.TextInput(attrs={"class": "datepicker", "autocomplete": "off"}))
    - date = forms.DateField(required=True,\n                           widget=forms.TextInput(attrs={"class": "datepicker", "autocomplete": "off"}))
    - date = forms.DateField(required=False, widget=forms.DateInput(attrs={"class": "datepicker"}))
    - date = forms.DateField(\n        label="",\n        widget=MonthYearWidget())
    - datetime.today().date()
    - def query_counts(\n    open_qs: MetricsQuerySet,\n    active_qs: MetricsQuerySet,\n    accepted_qs: MetricsQuerySet,\n    start_date: date,\n    metrics_type: MetricsType,\n) -> Callable[[MetricsPerio...
    - start_date = qs.earliest("date").date
    - end_date = qs.latest("date").date
    - def js_epoch(\n    d: date | datetime,\n) -> int:\n    """\n    Converts a date/datetime object to a JavaScript epoch time (for use in FE charts)\n\n    :param d: The date or datetime object\n    :ret...
    - isinstance(d, date)
    - def get_charting_data(\n    qs: MetricsQuerySet,\n    start_date: date,\n    period: MetricsPeriod,\n    period_count: int,\n    *,\n    include_closed: bool,\n) -> list[dict]:\n    """\n    Given a q...
    - cur_date.date()
    - if f.severity == "Critical":\n                total_critical.append(f)\n            elif f.severity == "High":\n                total_high.append(f)\n            elif f.severity == "Medium":\n        ...
    - if f.severity == "Critical":\n                total_critical.append(f)\n            elif f.severity == "High":\n                total_high.append(f)\n            elif f.severity == "Medium":\n        ...
    - Q(date=d)
    - date.today()
    - elapsed = date.today() - finding.date
    - date.today()
    - life = date.today() - find.date
    - date(iso_year, 1, 4)
    - start_date = findings_qs.earliest("date").date
    - end_date = findings_qs.latest("date").date
    - start_date = endpoints_qs.earliest("date").date
    - end_date = endpoints_qs.latest("date").date
    - date = iso_to_gregorian(iso_cal[0], iso_cal[1], 1)
    - date.strftime("<span class='small'>%m/%d<br/>%Y</span>")
    - date.timetuple()
    - timezone.now().date()
    - timezone.now().date()
    - timezone.now().date()
    - date.today()
    - date.today()
    - tz.now().date()
    - tz.now().date()
    - date.today()
    - Finding(\n                    title=textwrap.shorten(result_extended, 150),\n                    cwe=1032,  # Security Configuration Weaknesses, would like to fine tune\n                    test=test,...
    - date.fromisoformat(timestamp[:10])
    - Finding(\n                    title=textwrap.shorten(result_extended, 150),\n                    cwe=1032,  # Security Configuration Weaknesses, would like to fine tune\n                    test=test,...
    - date.fromisoformat(timestamp[:10])
    - Finding(\n                    title=textwrap.shorten(result_extended, 150),\n                    cwe=1032,  # Security Configuration Weaknesses, would like to fine tune\n                    test=test,...
    - date.fromisoformat(timestamp[:10])
    - self.date = generator.get(\n            "built",\n        )
    - Finding(\n            test=test,\n            title="Weak username / password combination found for " + host,\n            date=parse_datetime(metadata.date)\n            if metadata.date\n           ...
    - parse_datetime(metadata.date)
    - Finding(\n            test=test,\n            title="Weak username / password combination found for " + host,\n            date=parse_datetime(metadata.date)\n            if metadata.date\n           ...
    - date.today()
    - if f.mitigated is not None and end_of_period >= f.mitigated >= start_of_period:\n                o_count["closed"] += 1\n            elif f.mitigated is not None and f.mitigated > end_of_period and f....
    - end_of_period.date()
    - if f.mitigated is not None and end_of_period >= f.mitigated >= start_of_period:\n                o_count["closed"] += 1\n            elif f.mitigated is not None and f.mitigated > end_of_period and f....
    - end_of_period.date()
    - datetime.combine(finding.date, datetime.min.time(\n            ))
    - datetime.combine(finding.date, datetime.min.time())
    - f_time = finding.date
    - end_date.date()
    - end_date.date()
    - date(1900, month_number, 1)
    - def get_work_days(start: date, end: date):\n    """\n    Math function to get workdays between 2 dates.\n    Can be used only as fallback as it doesn't know\n    about specific country holidays or ext...
    - def get_work_days(start: date, end: date):\n    """\n    Math function to get workdays between 2 dates.\n    Can be used only as fallback as it doesn't know\n    about specific country holidays or ext...
    - parse(start_date).date()
    - f.get("mitigated").date()
    - timezone.now().date()
    - start_date.date()
    - f.get("mitigated").date()
    - timezone.now().date()
    - datetime.combine(f.date, datetime.min.time())
  datetime.UTC:
    - datetime.now(UTC)
  datetime.datetime:
    - datetime.combine(context.get("scan_date"), datetime.min.time())
    - datetime.min.time()
    - datetime.combine(findings.qs.last().date, datetime.min.time())
    - datetime.min.time()
    - datetime.combine(all_findings.last().date, datetime.min.time())
    - datetime.min.time()
    - datetime.combine(eng.target_start, datetime.min.time())
    - datetime.min.time()
    - datetime.combine(eng.target_end, datetime.max.time())
    - datetime.max.time()
    - isinstance(value, datetime)
    - datetime.today()
    - datetime.combine(\n                earliest_finding.date, datetime.min.time())
    - datetime.min.time()
    - datetime.combine(\n                earliest_finding.date, datetime.min.time())
    - datetime.min.time()
    - datetime(now().year, now().month, 1, 0, 0, 0)
    - datetime(now().year, 1, 1, 0, 0, 0)
    - datetime.combine(\n                earliest_finding.date, datetime.min.time())
    - datetime.min.time()
    - datetime.today()
    - datetime.now()
    - datetime.today()
    - def get_or_create_engagement(\n        self,\n        engagement_id: int = 0,\n        engagement_name: str | None = None,\n        product_name: str | None = None,\n        product_type_name: str | N...
    - self.scan_date: datetime = self.validate_scan_date(*args, **kwargs)
    - def validate_scan_date(\n        self,\n        *args: list,\n        **kwargs: dict,\n    ) -> datetime:\n        self.now = timezone.now()\n        value = self.validate(\n            "scan_date",\n...
    - self.validate(\n            "scan_date",\n            expected_types=[datetime],\n            required=False,\n            default=self.now,\n            **kwargs,\n        )
    - datetime.timedelta(seconds=30)
    - def get_date_range(\n    qs: QuerySet,\n) -> tuple[datetime, datetime]:\n    """\n    Given a queryset of objects, returns a tuple of (earliest date, latest date) from among those objects, based on th...
    - def get_date_range(\n    qs: QuerySet,\n) -> tuple[datetime, datetime]:\n    """\n    Given a queryset of objects, returns a tuple of (earliest date, latest date) from among those objects, based on th...
    - datetime(start_date.year, start_date.month, start_date.day, tzinfo=tz)
    - datetime(end_date.year, end_date.month, end_date.day, tzinfo=tz)
    - def js_epoch(\n    d: date | datetime,\n) -> int:\n    """\n    Converts a date/datetime object to a JavaScript epoch time (for use in FE charts)\n\n    :param d: The date or datetime object\n    :ret...
    - datetime.combine(d, datetime.min.time())
    - datetime.min.time()
    - datetime(start_date.year, start_date.month, start_date.day, tzinfo=tz)
    - datetime(start_date.year, start_date.month, 1, tzinfo=tz)
    - datetime(year, month, 1)
    - datetime(start_date.year,\n                                  start_date.month, start_date.day,\n                                  tzinfo=timezone.get_current_timezone())
    - datetime(end_date.year,\n                                end_date.month, end_date.day,\n                                tzinfo=timezone.get_current_timezone())
    - datetime(year, month, 1)
    - datetime(start_date.year,\n                                  start_date.month, start_date.day,\n                                  tzinfo=timezone.get_current_timezone())
    - datetime(end_date.year,\n                                end_date.month, end_date.day,\n                                tzinfo=timezone.get_current_timezone())
    - datetime(now.year,\n                                 now.month, 1,\n                                 tzinfo=timezone.get_current_timezone())
    - datetime(now.year,\n                                 now.month,\n                                 monthrange(now.year,\n                                            now.month)[1],\n                                 tzinfo=timezone.get_current_timezone())
    - datetime.strptime(\n            month[0].strip(), "%b %Y")
    - datetime(month_start.year,\n                             month_start.month,\n                             monthrange(\n                                 month_start.year,\n                                 month_start.month)[1],\n                             tzinfo=timezone.get_current_timezone())
    - datetime.strptime(\n            wk_range[0].strip() + " " + str(now.year), "%b %d %Y")
    - datetime.strptime(\n            wk_range[1].strip() + " " + str(now.year), "%b %d %Y")
    - isinstance(mitigated_date, datetime)
    - isinstance(start_date, datetime)
    - isinstance(mitigated_date, datetime)
    - isinstance(mitigated_date, datetime)
    - isinstance(mitigated_date, datetime)
    - datetime(\n            start_date.year,\n            start_date.month, start_date.day,\n            tzinfo=timezone.get_current_timezone())
    - datetime(\n            end_date.year,\n            end_date.month, end_date.day,\n            tzinfo=timezone.get_current_timezone())
    - datetime(start_date.year,\n                              start_date.month, start_date.day,\n                              tzinfo=timezone.get_current_timezone())
    - datetime(end_date.year,\n                            end_date.month, end_date.day,\n                            tzinfo=timezone.get_current_timezone())
    - datetime.combine(filters["start_date"], datetime.min.time())
    - datetime.min.time()
    - datetime.combine(findings.qs.last().date, datetime.min.time())
    - datetime.min.time()
    - isinstance(value, datetime)
    - datetime.datetime.now()
    - datetime.datetime.now()
    - datetime.datetime.now()
    - datetime.datetime.now()
    - datetime.combine(test.target_start, datetime.min.time())
    - datetime.min.time()
